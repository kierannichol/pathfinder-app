"use strict";
class e extends Error {
  constructor(e) {
    super(e);
  }
}
class t {
  constructor(e) {
    this.values = e;
  }
  asText() {
    return this.latest().asText();
  }
  asNumber() {
    return this.latest().asNumber();
  }
  asBoolean() {
    return this.latest().asBoolean();
  }
  asList() {
    return this.values;
  }
  equals(e) {
    const t = e.asList();
    if (t.length !== this.values.length) return !1;
    for (let e = 0; e < this.values.length; e++)
      if (!this.values[e].equals(t[e])) return !1;
    return !0;
  }
  toString() {
    return this.values.toString();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
  latest() {
    return 0 == this.values.length
      ? i.None
      : this.values[this.values.length - 1];
  }
}
class s {
  constructor(e) {
    this.value = e;
  }
  asText() {
    return this.value;
  }
  asNumber() {
    let t = parseFloat(this.value);
    if (Number.isNaN(t))
      throw new e(`Cannot convert '${this.value}' to a number`);
    return t;
  }
  asBoolean() {
    return !["false", "no", "0", ""].includes(this.value.toLowerCase());
  }
  asList() {
    return [this];
  }
  equals(e) {
    return e.hasValue() && this.value === e.asText();
  }
  toString() {
    return this.asText();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
}
class r {
  constructor(e) {
    this.value = e;
  }
  asText() {
    return this.value.toString();
  }
  asNumber() {
    return this.value;
  }
  asBoolean() {
    return this.value > 0;
  }
  asList() {
    return [this];
  }
  equals(e) {
    return e.hasValue() && this.value === e.asNumber();
  }
  toString() {
    return this.asText();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
}
class a {
  constructor(e) {
    this.value = e;
  }
  asBoolean() {
    return this.value;
  }
  asNumber() {
    return this.value ? 1 : 0;
  }
  asText() {
    return this.value ? "true" : "false";
  }
  asList() {
    return [this];
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
  equals(e) {
    return e.hasValue() && this.value === e.asBoolean();
  }
  toString() {
    return this.asText();
  }
}
class n {
  asBoolean() {
    return !1;
  }
  asNumber() {
    return 0;
  }
  asText() {
    return "";
  }
  asList() {
    return [];
  }
  map(e) {
    return this;
  }
  hasValue() {
    return !1;
  }
  equals(e) {
    return !e.hasValue();
  }
  toString() {
    return this.asText();
  }
}
n.Instance = new n();
class i {
  static of(e) {
    return void 0 === e
      ? n.Instance
      : "string" == typeof e
      ? new s(e)
      : "number" == typeof e
      ? new r(e)
      : "boolean" == typeof e
      ? e
        ? i.True
        : i.False
      : Array.isArray(e)
      ? new t(e.map(i.of))
      : e;
  }
}
(i.True = new a(!0)), (i.False = new a(!1)), (i.None = n.Instance);
class o {
  constructor(e, t) {
    (this.id = e), (this.value = t);
  }
  asBoolean() {
    return this.value.asBoolean();
  }
  asNumber() {
    return this.value.asNumber();
  }
  asText() {
    return this.value.asText();
  }
  asList() {
    return this.value.asList();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return this.value.hasValue();
  }
  equals(e) {
    return this.value.equals(e);
  }
}
class u {
  static just(e) {
    return e instanceof i
      ? new u.StaticResolvable(e)
      : new u.StaticResolvable(i.of(e));
  }
  map(e) {
    return new u.MappedResolvable(this, e);
  }
}
(u.StaticResolvable = class extends u {
  constructor(e) {
    super(), (this.resolved = e);
  }
  resolve(e) {
    return this.resolved;
  }
  asFormula() {
    return this.resolved.asText();
  }
}),
  (u.MappedResolvable = class extends u {
    constructor(e, t) {
      super(), (this.resolvable = e), (this.mapFn = t);
    }
    resolve(e) {
      return this.mapFn(this.resolvable.resolve(e));
    }
    asFormula() {
      return this.resolvable.asFormula();
    }
  }),
  (u.True = new u.StaticResolvable(i.True)),
  (u.False = new u.StaticResolvable(i.False)),
  (u.None = new u.StaticResolvable(i.None));
class c {
  constructor(e, t) {
    (this.value = e), (this.name = t);
  }
  asBoolean() {
    return this.value.asBoolean();
  }
  asNumber() {
    return this.value.asNumber();
  }
  asText() {
    return this.value.asText();
  }
  asList() {
    return this.value.asList();
  }
  asName() {
    return this.name;
  }
  map(e) {
    return e(this);
  }
  equals(e) {
    return this.value.equals(e);
  }
  hasValue() {
    return this.value.hasValue();
  }
}
class h {
  constructor(e, t, s) {
    (this.value = e), (this.prefix = t), (this.suffix = s);
  }
  asBoolean() {
    return this.value.asBoolean();
  }
  asNumber() {
    return this.value.asNumber();
  }
  asText() {
    return this.value.asText();
  }
  asList() {
    return this.value.asList();
  }
  asQuotedText() {
    return this.prefix + this.asText() + this.suffix;
  }
  map(e) {
    return e(this);
  }
  equals(e) {
    return this.value.equals(e);
  }
  hasValue() {
    return this.value.hasValue();
  }
}
class l {
  static of(e) {
    return new d(e);
  }
}
l.Empty = new (class {
  get(e) {}
  keys() {
    return [];
  }
  search(e) {
    return [];
  }
})();
class p {
  search(e) {
    return f.find(this, e);
  }
}
class f {
  static find(e, t) {
    if (!t.includes("*")) return [new o(t, e.get(t))];
    const s = new RegExp(this.escapeRegExp(t).replace(/\\\*/g, ".*?"));
    return e
      .keys()
      .filter((e) => s.test(e))
      .map((t) => {
        const s = e.get(t);
        if (void 0 !== s) return new o(t, s);
      })
      .filter((e) => void 0 !== e)
      .map((e) => e);
  }
  static escapeRegExp(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
}
class d extends p {
  constructor(e) {
    super(), (this.state = e);
  }
  get(e) {
    const s = this.state[e];
    return s instanceof u
      ? s.resolve(this)
      : Array.isArray(s)
      ? new t(s.map((e) => (e instanceof u ? e.resolve(this) : i.of(e))))
      : i.of(s);
  }
  set(e, t) {
    this.state[e] = t;
  }
  push(e, t) {
    const s = this.state[e];
    void 0 === s
      ? (this.state[e] = [t])
      : Array.isArray(s)
      ? s.push(t)
      : (this.state[e] = [s, t]);
  }
  remove(e) {
    delete this.state[e];
  }
  keys() {
    return Object.keys(this.state);
  }
  rename(e, t) {
    e in this.state && ((this.state[t] = this.state[e]), delete this.state[e]);
  }
}
class m extends p {
  constructor(e = {}) {
    super(), (this.state = e);
  }
  get(e) {
    const s = this.state[e];
    return s instanceof u
      ? s.resolve(this)
      : Array.isArray(s)
      ? new t(s.map((e) => (e instanceof u ? e.resolve(this) : i.of(e))))
      : i.of(s);
  }
  replace(e, t) {
    return new m(Object.assign(Object.assign({}, this.state), { [e]: t }));
  }
  remove(e) {
    const t = Object.assign({}, this.state);
    return delete t[e], new m(t);
  }
  rename(e, t) {
    const s = Object.assign({}, this.state);
    return (s[t] = s[e]), delete s[e], new m(s);
  }
  push(e, t) {
    const s = Object.assign({}, this.state),
      r = s[e];
    return (
      void 0 === r
        ? (s[e] = [t])
        : Array.isArray(r)
        ? (s[e] = [...r, t])
        : (s[e] = [r, t]),
      new m(s)
    );
  }
  keys() {
    return Object.keys(this.state);
  }
}
const v = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
  x = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
  ],
  w = [...[...x, ...v], "_"];
class b extends Error {
  constructor(e) {
    super(e);
  }
}
class g {
  constructor() {
    this.root = new k();
  }
  ignoreWhitespaces() {
    return this.add(" ", (e) => {});
  }
  add(e, t) {
    return "string" != typeof e
      ? ((s = e), (e = Array.isArray(s) ? s : [s]), this.addBranch(e, t))
      : this.addBranch([O(e)], t);
    var s;
  }
  addBranch(e, t) {
    return T.of(e).chainTo(this.root, t), this;
  }
  parse(e) {
    const t = [];
    for (let s = 0; s < e.length; s++) {
      const r = this.root.walk(e, s);
      if (!(r.length > 0))
        throw new b(
          g.generateParseErrorMessage(
            s,
            e,
            `did not expect character: '${e[s]}'`
          )
        );
      {
        const e = r[0],
          a = e.get();
        void 0 !== a && t.push(a), (s = e.endIndex - 1);
      }
    }
    return t;
  }
  static generateParseErrorMessage(e, t, s) {
    let r = `Parse error at index ${e} of "${t}": ${s}`;
    return (r += `\n${t}\n${" ".repeat(e)}^`), r;
  }
}
class N {
  constructor(e, t, s, r) {
    (this.text = e),
      (this.startIndex = t),
      (this.endIndex = s),
      (this.mapper = r);
  }
  get() {
    return this.mapper(this.text.substring(this.startIndex, this.endIndex));
  }
}
class y {
  static match(e) {
    return new L(e);
  }
}
class L extends y {
  constructor(e) {
    super(), (this.matcher = e);
  }
  node() {
    return new R(this.matcher);
  }
  repeats(e = 0, t = undefined) {
    return new A(this.matcher, e, t);
  }
  optional() {
    return this.repeats(0, 1);
  }
  not() {
    return new L(new C(this.matcher));
  }
}
class A extends y {
  constructor(e, t, s) {
    super(), (this.matcher = e), (this.minLength = t), (this.maxLength = s);
  }
  node() {
    return new B(this.matcher, this.minLength, this.maxLength);
  }
}
class F extends y {
  constructor(e, t) {
    super(), (this.closeSequence = e), (this.escapeSequence = t);
  }
  node() {
    return new S(this.closeSequence, this.escapeSequence);
  }
}
class T {
  static of(e) {
    return new T(e);
  }
  constructor(e) {
    this.expressions = e;
  }
  chainTo(e, t, s = !0) {
    let r = e;
    for (let e of this.expressions)
      r = e instanceof y ? r.add(e.node()) : e.chainTo(r, t, !1);
    if (s) {
      let e = r;
      if (void 0 !== e.mapper) throw new Error("Conflicting tokens");
      e.mapper = t;
    }
    return r;
  }
}
class $ {
  static of(e) {
    return new $(e);
  }
  constructor(e) {
    this.expressions = e;
  }
  chainTo(e, t, s = !0) {
    let r = e;
    r.mapper = t;
    for (let e of this.expressions)
      r = e instanceof q ? r.add(e) : e.chainTo(r, t, !1);
    if (s) {
      let e = r;
      if (void 0 !== e.mapper) throw new Error("Conflicting tokens");
      e.mapper = t;
    }
    return r;
  }
}
class q {
  constructor() {
    (this.id = q.idCounter++), (this.children = void 0);
  }
  add(e) {
    void 0 === this.children && (this.children = []);
    for (let t of this.children) if (t.equals(e)) return t;
    return this.children.push(e), e;
  }
  walkChildren(e, t, s) {
    return void 0 === this.children
      ? []
      : this.children.flatMap((r) => r.walk(e, t, s));
  }
}
q.idCounter = 1;
class k extends q {
  walk(e, t = 0, s = t) {
    return this.walkChildren(e, t, s);
  }
  equals(e) {
    return !1;
  }
}
class R extends q {
  constructor(e) {
    super(), (this.matcher = e), (this.mapper = void 0);
  }
  walk(e, t, s) {
    if (!this.matches(e, t, s)) return [];
    const r = this.walkChildren(e, t, s + 1);
    return r.length > 0
      ? r
      : void 0 !== this.mapper
      ? [new N(e, t, s + 1, this.mapper)]
      : [];
  }
  matches(e, t, s) {
    const r = e[s];
    return void 0 !== r && this.matcher.matches(r);
  }
  equals(e) {
    return e instanceof R && this.matcher.equals(e.matcher);
  }
}
class B extends q {
  constructor(e, t, s) {
    super(),
      (this.matcher = e),
      (this.minLength = t),
      (this.maxLength = s),
      (this.mapper = void 0);
  }
  walk(e, t, s) {
    const r = this.minLength,
      a = this.calculateMaxLength(e, s);
    let n = 0;
    for (
      let t = e[s];
      void 0 !== t && this.matcher.matches(t) && n < a;
      t = e[s]
    )
      s++, n++;
    if (n < r) return [];
    const i = this.walkChildren(e, t, s);
    return n > a || i.length > 0
      ? i
      : void 0 !== this.mapper
      ? [new N(e, t, s, this.mapper)]
      : [];
  }
  equals(e) {
    return (
      e instanceof B &&
      this.matcher.equals(e.matcher) &&
      this.minLength === e.minLength &&
      this.maxLength === e.maxLength
    );
  }
  calculateMaxLength(e, t) {
    const s = e.length - t;
    return void 0 !== this.maxLength ? Math.min(this.maxLength, s) : s;
  }
}
class S extends q {
  constructor(e, t) {
    super(),
      (this.closeSequence = e),
      (this.escapeSequence = t),
      (this.mapper = void 0);
  }
  walk(e, t, s) {
    for (; s < e.length; s++)
      for (
        let r = 0;
        r < this.closeSequence.length &&
        e[s + r] === this.closeSequence[r] &&
        !this.isEscaped(e, s);
        r++
      )
        if (r === this.closeSequence.length - 1) {
          const r = this.walkChildren(e, t, s);
          return r.length > 0
            ? r
            : void 0 !== this.mapper && s > t
            ? [new N(e, t, s, this.mapper)]
            : [];
        }
    return void 0 !== this.mapper && s === e.length
      ? [new N(e, t, s, this.mapper)]
      : [];
  }
  isEscaped(e, t) {
    if (void 0 === this.escapeSequence) return !1;
    for (
      let s = t - this.escapeSequence.length + 1, r = 0;
      r < this.escapeSequence.length;
      s++, r++
    ) {
      if (s < 0 && s >= t) return !1;
      if (e[s] !== this.escapeSequence[r]) return !1;
    }
    return !0;
  }
  equals(e) {
    return e instanceof S && this.closeSequence === e.closeSequence;
  }
}
class M {
  constructor(e) {
    this.character = e;
  }
  matches(e) {
    return this.character === e;
  }
  equals(e) {
    return e instanceof M && this.character === e.character;
  }
}
class E {
  constructor(e) {
    this.allowed = e;
  }
  matches(e) {
    return this.allowed.includes(e);
  }
  equals(e) {
    return (
      e instanceof E &&
      (function (e, t) {
        if (e.length !== t.length) return !1;
        for (let s = 0; s < e.length; s++) if (e[s] !== t[s]) return !1;
        return !0;
      })(this.allowed, e.allowed)
    );
  }
}
class V {
  matches(e) {
    return void 0 !== e;
  }
  equals(e) {
    return e instanceof E;
  }
}
class C {
  constructor(e) {
    this.matcher = e;
  }
  matches(e) {
    return !this.matcher.matches(e);
  }
  equals(e) {
    return e instanceof C && this.matcher.equals(e.matcher);
  }
}
function I(e) {
  return (
    Array.isArray(e) && 1 === e.length && (e = e[0]),
    y.match(Array.isArray(e) ? new E(e) : new M(e))
  );
}
function O(e) {
  return T.of(Array.from(e).map((e) => I(e)));
}
function j(...e) {
  return T.of(e.map((e) => ("string" == typeof e ? O(e) : e)));
}
function P(...e) {
  return $.of([j(...e)]);
}
function U(e, t, s = undefined) {
  return j(
    O(e),
    (function (e, t = undefined) {
      return j(new F(e, t));
    })(t, s),
    O(t)
  );
}
new (class extends y {
  constructor() {
    super(), (this.matcher = new V());
  }
  node() {
    return new R(this.matcher);
  }
  except(...e) {
    return new L(new C(new E(e)));
  }
  repeats(e = 0, t = undefined) {
    return new A(this.matcher, e, t);
  }
  optional() {
    return this.repeats(0, 1);
  }
  not() {
    return new L(new C(this.matcher));
  }
})();
const D = j(I(v).repeats(1));
j(I(w).repeats(1));
const z = j(I([...w, ":", ".", "#", "*"]).repeats(1)),
  Q = j(D),
  W = j(Q, ".", D);
j(Q, P(".", D));
const Y = I(x);
function G(e, t) {
  switch (e) {
    case 0:
      return () => i.of(t());
    case 1:
      return (e) => {
        var s;
        return i.of(
          t(
            null !== (s = null == e ? void 0 : e.asNumber()) && void 0 !== s
              ? s
              : 0
          )
        );
      };
    case 2:
      return (e, s) => {
        var r, a;
        return i.of(
          t(
            null !== (r = null == e ? void 0 : e.asNumber()) && void 0 !== r
              ? r
              : 0,
            null !== (a = null == s ? void 0 : s.asNumber()) && void 0 !== a
              ? a
              : 0
          )
        );
      };
    case 3:
      return (e, s, r) => {
        var a, n, o;
        return i.of(
          t(
            null !== (a = null == e ? void 0 : e.asNumber()) && void 0 !== a
              ? a
              : 0,
            null !== (n = null == s ? void 0 : s.asNumber()) && void 0 !== n
              ? n
              : 0,
            null !== (o = null == r ? void 0 : r.asNumber()) && void 0 !== o
              ? o
              : 0
          )
        );
      };
    default:
      throw new Error(`Unsupported number of operands: ${e}`);
  }
}
var H;
(exports.Associativity = void 0),
  ((H = exports.Associativity || (exports.Associativity = {}))[(H.Left = 1)] =
    "Left"),
  (H[(H.Right = 2)] = "Right");
class J {
  constructor(e, t, s) {
    (this.name = e), (this.operands = t), (this.fn = s);
  }
  execute(e, t, s) {
    switch (this.operands) {
      case 0:
        return this.fn();
      case 1:
        return this.fn(e);
      case 2:
        return this.fn(e, t);
      case 3:
        return this.fn(e, t, s);
      default:
        throw new Error(`Unsupported number of operands: ${this.operands}`);
    }
  }
}
class K extends J {
  constructor(e, t, s) {
    super(e, t, s);
  }
}
class X {
  constructor(e, t) {
    (this.name = e), (this.fn = t);
  }
  execute(e) {
    return this.fn(e);
  }
}
class Z extends J {
  constructor(e, t, s, r, a) {
    super(e, r, a),
      (this.name = e),
      (this.precedence = t),
      (this.associativity = s);
  }
}
class _ {
  constructor(e, t) {
    (this.unary = e), (this.binary = t);
  }
}
class ee {
  constructor(e, t) {
    (this.key = e), (this.resolver = t);
  }
  resolve(e) {
    var t;
    return null !== (t = this.resolver(e, this.key)) && void 0 !== t
      ? t
      : i.None;
  }
  toString() {
    return this.key;
  }
}
class te {
  constructor(e, t) {
    (this.text = e), (this.decorator = t);
  }
  apply(e) {
    return this.decorator(this.text, e);
  }
}
class se {
  constructor(e, t = undefined, s = undefined) {
    (this.resolver = e), (this.prefix = t), (this.suffix = s);
  }
  resolve(e) {
    return this.prefix && this.suffix
      ? this.resolver(e).map((e) => new h(e, this.prefix, this.suffix))
      : this.resolver(e);
  }
}
class re {
  constructor() {
    (this.bracketFn = (e) => e),
      (this.parser = new g()
        .ignoreWhitespaces()
        .add([Q], (e) => parseInt(e))
        .add([W], (e) => parseFloat(e))
        .add("(", (e) => e)
        .add(")", (e) => e)
        .add(",", (e) => e)
        .add(
          U('"', '"', '\\"'),
          (e) => new se(() => i.of(e.slice(1, -1)), '"', '"')
        )
        .add(
          U("'", "'", "\\'"),
          (e) => new se(() => i.of(e.slice(1, -1)), "'", "'")
        ));
  }
  operator(e, t, s, r, a) {
    return this.parser.add(e, (n) => new Z(e, t, s, r, a)), this;
  }
  biOperator(e, t, s, r, a, n, i) {
    return (
      this.parser.add(
        e,
        (o) => new _(new Z(e, t, s, 1, r), new Z(e, a, n, 2, i))
      ),
      this
    );
  }
  intOperator(e, t, s, r, a) {
    return this.operator(e, t, s, r, G(r, a));
  }
  function(e, t, s) {
    return this.parser.add(e, (r) => new K(e, t, s)), this;
  }
  varargsFunction(e, t) {
    return this.parser.add(e, (s) => new X(e, t)), this;
  }
  intFunction(e, t, s) {
    return this.function(e, t, G(t, s));
  }
  variable(e, t, s) {
    return (
      this.parser.add(
        [O(e), Y, P(z), O(t)],
        (r) =>
          new ee(r, (r, a) => s(r, a.substring(e.length, a.length - t.length)))
      ),
      this
    );
  }
  comment(e, t, s = (e, t) => t) {
    return (
      this.parser.add(
        U(e, t),
        (r) => new te(r.substring(e.length, r.length - t.length), s)
      ),
      this
    );
  }
  term(e, t) {
    return this.parser.add([O(e)], (e) => new ee(e, (e) => t(e))), this;
  }
  brackets(e) {
    return (this.bracketFn = e), this;
  }
  parse(e) {
    let t = [],
      s = [],
      r = [];
    const a = this.parser.parse(e);
    for (let e = 0; e < a.length; e++) {
      let n = a[e],
        o = e > 0 ? a[e - 1] : void 0;
      if (n instanceof _) {
        let e = n;
        (n = e.binary),
          (!o || o instanceof Z || "(" === o || "," === o) && (n = e.unary);
      }
      if (n instanceof Z) {
        let e = n,
          r = s.at(-1);
        r instanceof Z &&
          (e.precedence < r.precedence ||
            (e.associativity === exports.Associativity.Left &&
              e.precedence === r.precedence)) &&
          (s.pop(), t.push(r)),
          s.push(e);
      } else if (n instanceof K) s.push(n), r.push(1);
      else if (n instanceof X) s.push(n), r.push(1);
      else if (n instanceof ee) t.push(n);
      else if (n instanceof se) t.push(n);
      else if (n instanceof te) t.push(n);
      else
        switch (n) {
          case " ":
          case "{":
          case "}":
            break;
          case ",":
            for (r[r.length - 1]++; s.length > 0; ) {
              let e = s.pop();
              if ("(" === e) {
                s.push(e);
                break;
              }
              t.push(e);
            }
            break;
          case "(":
            s.push(n);
            break;
          case ")":
            for (; s.length > 0; ) {
              let e = s.pop();
              if ("(" === e) break;
              t.push(e);
            }
            if (s.at(-1) instanceof K) {
              const e = r.pop(),
                a = s.pop();
              if (e !== a.operands)
                throw new Error(
                  `${a.name} expected ${a.operands} parameters, but got ${e}`
                );
              t.push(a);
            } else if (s.at(-1) instanceof X) {
              let e = r.pop();
              (e = "(" === o ? 0 : e), t.push(e), t.push(s.pop());
            }
            break;
          default:
            t.push(i.of(n));
        }
    }
    for (; s.length > 0; ) t.push(s.pop());
    return new ae(t, e);
  }
}
class ae extends u {
  static parser() {
    return new re();
  }
  constructor(e, t) {
    super(), (this.stack = e), (this.originalFormula = t);
  }
  asFormula() {
    return this.originalFormula;
  }
  resolve(t = l.Empty) {
    let s = [],
      r = [...this.stack];
    for (; r.length > 0; ) {
      let a = r.shift();
      if (a instanceof J) {
        let t = a;
        if (0 === t.operands) s.push(t.execute());
        else if (1 === t.operands) {
          let r = s.pop();
          if (void 0 === r) throw new e(`Missing parameter #1 for "${t.name}"`);
          s.push(t.execute(r));
        } else if (2 === t.operands) {
          let r = s.pop(),
            a = s.pop();
          if (void 0 === r) throw new e(`Missing parameter #1 for "${t.name}"`);
          if (void 0 === a) throw new e(`Missing parameter #2 for "${t.name}"`);
          s.push(t.execute(a, r));
        } else {
          if (3 !== t.operands)
            throw new Error("Unsupported number of operands: " + t.operands);
          {
            let r = s.pop(),
              a = s.pop(),
              n = s.pop();
            if (void 0 === r)
              throw new e(`Missing parameter #1 for "${t.name}"`);
            if (void 0 === a)
              throw new e(`Missing parameter #2 for "${t.name}"`);
            if (void 0 === n)
              throw new e(`Missing parameter #3 for "${t.name}"`);
            s.push(t.execute(n, a, r));
          }
        }
      } else if (a instanceof X) {
        let e = a,
          t = [],
          r = s.pop();
        for (; r-- > 0; ) t.unshift(s.pop());
        s.push(e.execute(t));
      } else if (a instanceof te) {
        const e = s.pop();
        s.push(a.apply(e));
      } else if (
        (a instanceof se && (a = a.resolve(t)),
        a instanceof ee && ((a = a.resolve(t)), a instanceof ae))
      ) {
        const e = a.stack;
        for (let t = e.length - 1; t >= 0; t--) r.unshift(e[t]);
      } else {
        for (; a instanceof u; ) a = a.resolve(t);
        s.push(a);
      }
    }
    return s.pop();
  }
}
function ne(e) {
  return (...t) => i.of(e(...t.map(oe)));
}
function ie(e) {
  return (...t) => i.of(`${e}(${t.map(oe).join(",")})`);
}
function oe(e) {
  return e instanceof h ? e.asQuotedText() : e.asText();
}
class ue extends i {
  asNumber() {
    throw ue.UnsupportedException;
  }
  asBoolean() {
    throw ue.UnsupportedException;
  }
  asList() {
    throw ue.UnsupportedException;
  }
}
ue.UnsupportedException = new Error("Not available for optimization");
class ce extends ue {
  constructor(e) {
    super(), (this.values = []);
    let t = !1,
      s = !1;
    e.forEach((e) => {
      e instanceof ce
        ? this.values.push(...e.values)
        : e !== i.False
        ? e !== i.True
          ? this.values.push(e)
          : (t = !0)
        : (s = !0);
    }),
      t && (this.values = [i.True]),
      0 === this.values.length && (this.values = [s ? i.False : i.True]);
  }
  asText() {
    return 1 === this.values.length
      ? oe(this.values[0])
      : `any(${this.values.map(oe).join(",")})`;
  }
}
class he extends ue {
  constructor(e) {
    super(), (this.values = []);
    let t = !1;
    e.forEach((e) => {
      e instanceof he
        ? this.values.push(...e.values)
        : e !== i.True && (e !== i.False ? this.values.push(e) : (t = !0));
    }),
      t && (this.values = [i.False]),
      0 === this.values.length && (this.values = [i.True]);
  }
  asText() {
    return 1 === this.values.length
      ? oe(this.values[0])
      : `all(${this.values.map(oe).join(",")})`;
  }
}
class le extends ue {
  static create(e) {
    return (t, s) => new le(e, t, s);
  }
  constructor(e, t, s) {
    super(), (this.operator = e), (this.a = t), (this.b = s);
  }
  asText() {
    return `(${this.asTextNoBrackets()})`;
  }
  asTextNoBrackets() {
    return this.format(this.a) + this.operator + this.format(this.b);
  }
  format(e) {
    if (e instanceof le) {
      if (
        !(
          ("+" != e.operator && "-" != e.operator) ||
          ("+" != this.operator && "-" != this.operator)
        )
      )
        return e.asTextNoBrackets();
      if (
        !(
          ("*" != e.operator && "/" != e.operator) ||
          ("*" != this.operator && "/" != this.operator)
        )
      )
        return e.asTextNoBrackets();
    }
    return oe(e);
  }
}
class pe {
  static optimize(e) {
    const t = this.Parser.parse(e).resolve();
    return t instanceof le ? t.asTextNoBrackets() : oe(t);
  }
}
pe.Parser = ae
  .parser()
  .operator("^", 4, exports.Associativity.Right, 2, le.create("^"))
  .operator("*", 3, exports.Associativity.Left, 2, le.create("*"))
  .operator("/", 3, exports.Associativity.Left, 2, le.create("/"))
  .operator("+", 2, exports.Associativity.Left, 2, le.create("+"))
  .operator("-", 2, exports.Associativity.Left, 2, le.create("-"))
  .operator(
    "!",
    2,
    exports.Associativity.Left,
    1,
    ne((e) => `!${e}`)
  )
  .operator(
    "<",
    3,
    exports.Associativity.Left,
    2,
    ne((e, t) => `${e}<${t}`)
  )
  .operator(
    "<=",
    3,
    exports.Associativity.Left,
    2,
    ne((e, t) => `${e}<=${t}`)
  )
  .operator(
    ">",
    3,
    exports.Associativity.Left,
    2,
    ne((e, t) => `${e}>${t}`)
  )
  .operator(
    ">=",
    3,
    exports.Associativity.Left,
    2,
    ne((e, t) => `${e}>=${t}`)
  )
  .operator(
    "==",
    3,
    exports.Associativity.Left,
    2,
    ne((e, t) => `${e}==${t}`)
  )
  .operator(
    "!=",
    3,
    exports.Associativity.Left,
    2,
    ne((e, t) => `${e}!=${t}`)
  )
  .operator("AND", 1, exports.Associativity.Left, 2, (e, t) => new he([e, t]))
  .operator("OR", 1, exports.Associativity.Left, 2, (e, t) => new ce([e, t]))
  .operator(
    "d",
    4,
    exports.Associativity.Left,
    2,
    ne((e, t) => `${e}d${t}`)
  )
  .term("true", () => i.of(!0))
  .term("false", () => i.of(!1))
  .term("null", () => i.of("null"))
  .function("abs", 1, ie("abs"))
  .function("min", 2, ie("min"))
  .function("max", 2, ie("max"))
  .function("floor", 1, ie("floor"))
  .function("ceil", 1, ie("ceil"))
  .function("signed", 1, ie("signed"))
  .function("if", 3, ie("if"))
  .function("concat", 2, ie("concat"))
  .function("ordinal", 1, ie("ordinal"))
  .varargsFunction("any", (e) => new ce(e))
  .varargsFunction("all", (e) => new he(e))
  .variable("@", "", (e, t) => i.of(`@${t}`))
  .variable("@{", "}", (e, t) => i.of(`@{${t}}`))
  .variable("min(@", ")", (e, t) => i.of(`min(@${t})`))
  .variable("max(@", ")", (e, t) => i.of(`max(@${t})`))
  .variable("sum(@", ")", (e, t) => i.of(`sum(@${t})`))
  .comment("[", "]", (e, t) => new h(t, "", `[${e}]`));
class fe {
  constructor(e, t) {
    (this.count = e), (this.sides = t);
  }
  asText() {
    return this.count + "d" + this.sides;
  }
  asNumber() {
    return (this.count * (this.sides + 1)) / 2;
  }
  asBoolean() {
    return this.count > 0 && this.sides > 0;
  }
  asList() {
    return [this];
  }
  equals(e) {
    return e.hasValue() && this.asText() === e.asText();
  }
  toString() {
    return this.asText();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
}
class de {
  static parse(e) {
    return e instanceof u ? e : this.Parser.parse(e);
  }
  static optimize(e) {
    return pe.optimize(e);
  }
  static noneIfEmpty(e) {
    return e.length > 0 ? e : [];
  }
  static variableFn(e, t) {
    return e.get(t);
  }
  static minFn(e, t) {
    return de
      .noneIfEmpty(e.search(t))
      .flatMap((e) => e.asList())
      .reduce(de.minReduceFn, i.None);
  }
  static maxFn(e, t) {
    return de
      .noneIfEmpty(e.search(t))
      .flatMap((e) => e.asList())
      .reduce(de.maxReduceFn, i.None);
  }
  static sumFn(e, t) {
    return e
      .search(t)
      .flatMap((e) => e.asList())
      .reduce(de.addReduceFn, i.of(0));
  }
  static sumMaxFn(e, t) {
    return e
      .search(t)
      .flatMap((e) => e.asList().reduce(de.maxReduceFn))
      .reduce(de.addReduceFn, i.of(0));
  }
  static sumMinFn(e, t) {
    return e
      .search(t)
      .flatMap((e) => e.asList().reduce(de.minReduceFn))
      .reduce(de.addReduceFn, i.of(0));
  }
  static concatFn(e) {
    return i.of(e.flatMap((e) => e.asList()));
  }
  static addReduceFn(e, t) {
    return (null != e ? e : i.None).equals(i.None) &&
      (null != t ? t : i.None).equals(i.None)
      ? i.None
      : i.of(e.asNumber() + t.asNumber());
  }
  static maxReduceFn(e, t) {
    var s;
    return null !== (s = de.notNone(e, t)) && void 0 !== s
      ? s
      : e.asNumber() > t.asNumber()
      ? e
      : t;
  }
  static minReduceFn(e, t) {
    var s;
    return null !== (s = de.notNone(e, t)) && void 0 !== s
      ? s
      : e.asNumber() < t.asNumber()
      ? e
      : t;
  }
  static notNone(e, t) {
    return e.hasValue() || t.hasValue()
      ? e.hasValue()
        ? t.hasValue()
          ? null
          : e
        : t
      : i.None;
  }
}
(de.Parser = ae
  .parser()
  .biOperator(
    "-",
    4,
    exports.Associativity.Left,
    (e) => i.of(-e.asNumber()),
    2,
    exports.Associativity.Left,
    (e, t) => i.of(e.asNumber() - t.asNumber())
  )
  .operator("^", 4, exports.Associativity.Right, 2, (e, t) =>
    i.of(Math.pow(e.asNumber(), t.asNumber()))
  )
  .operator("*", 3, exports.Associativity.Left, 2, (e, t) =>
    i.of(e.asNumber() * t.asNumber())
  )
  .operator("/", 3, exports.Associativity.Left, 2, (e, t) =>
    i.of(e.asNumber() / t.asNumber())
  )
  .operator("+", 2, exports.Associativity.Left, 2, de.addReduceFn)
  .operator("!", 2, exports.Associativity.Left, 1, (e) => i.of(!e.asBoolean()))
  .operator("<", 3, exports.Associativity.Left, 2, (e, t) =>
    i.of(e.asNumber() < t.asNumber())
  )
  .operator("<=", 3, exports.Associativity.Left, 2, (e, t) =>
    i.of(e.asNumber() <= t.asNumber())
  )
  .operator(">", 3, exports.Associativity.Left, 2, (e, t) =>
    i.of(e.asNumber() > t.asNumber())
  )
  .operator(">=", 3, exports.Associativity.Left, 2, (e, t) =>
    i.of(e.asNumber() >= t.asNumber())
  )
  .operator("==", 3, exports.Associativity.Left, 2, (e, t) => i.of(e.equals(t)))
  .operator("!=", 3, exports.Associativity.Left, 2, (e, t) =>
    i.of(!e.equals(t))
  )
  .operator("AND", 1, exports.Associativity.Left, 2, (e, t) =>
    i.of(e.asBoolean() && t.asBoolean())
  )
  .operator("OR", 1, exports.Associativity.Left, 2, (e, t) =>
    i.of(e.asBoolean() || t.asBoolean())
  )
  .operator(
    "d",
    4,
    exports.Associativity.Left,
    2,
    (e, t) => new fe(e.asNumber(), t.asNumber())
  )
  .term("true", () => i.of(!0))
  .term("false", () => i.of(!1))
  .term("null", () => i.None)
  .function("abs", 1, (e) => i.of(Math.abs(e.asNumber())))
  .function("min", 2, (e, t) => i.of(Math.min(e.asNumber(), t.asNumber())))
  .function("max", 2, (e, t) => i.of(Math.max(e.asNumber(), t.asNumber())))
  .function("floor", 1, (e) => i.of(Math.floor(e.asNumber())))
  .function("ceil", 1, (e) => i.of(Math.ceil(e.asNumber())))
  .function("signed", 1, (e) =>
    i.of((e.asNumber() < 0 ? "" : "+") + e.asNumber())
  )
  .function("if", 3, (e, t, s) => (e.asBoolean() ? t : s))
  .varargsFunction("concat", de.concatFn)
  .function("ordinal", 1, (e) =>
    i.of(
      (function (e) {
        let t = ["th", "st", "nd", "rd"],
          s = e % 100;
        return e + (t[(s - 20) % 10] || t[s] || t[0]);
      })(e.asNumber())
    )
  )
  .varargsFunction("any", (e) => i.of(e.some((e) => e.asBoolean())))
  .varargsFunction("all", (e) => i.of(e.every((e) => e.asBoolean())))
  .variable("@", "", de.variableFn)
  .variable("@{", "}", de.variableFn)
  .variable("min(@", ")", de.minFn)
  .variable("max(@", ")", de.maxFn)
  .variable("sum(@", ")", de.sumFn)
  .variable("sum(max(@", "))", de.sumMaxFn)
  .variable("sum(min(@", "))", de.sumMinFn)
  .comment("[", "]", (e, t) => new c(t, e))),
  (exports.BaseDataContext = p),
  (exports.DataContext = l),
  (exports.Formula = de),
  (exports.ImmutableDataContext = class {
    static of(e) {
      return new m(e);
    }
  }),
  (exports.NamedResolvedValue = c),
  (exports.QuotedTextResolvedValue = h),
  (exports.Resolvable = u),
  (exports.ResolveError = e),
  (exports.ResolvedValue = i),
  (exports.ResolvedValueWithId = o),
  (exports.ShuntingYard = ae),
  (exports.ShuntingYardParser = re);
//# sourceMappingURL=index.cjs.js.map
