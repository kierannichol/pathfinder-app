class e extends Error {
  constructor(e) {
    super(e);
  }
}
class t {
  constructor(e) {
    this.value = e;
  }
  asText() {
    return this.value;
  }
  asNumber() {
    let t = parseFloat(this.value);
    if (Number.isNaN(t))
      throw new e(`Cannot convert '${this.value}' to a number`);
    return t;
  }
  asBoolean() {
    return !["false", "no", "0", ""].includes(this.value.toLowerCase());
  }
  equals(e) {
    return e.hasValue() && this.value === e.asText();
  }
  toString() {
    return this.asText();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
}
class s {
  constructor(e) {
    this.value = e;
  }
  asText() {
    return this.value.toString();
  }
  asNumber() {
    return this.value;
  }
  asBoolean() {
    return this.value > 0;
  }
  equals(e) {
    return e.hasValue() && this.value === e.asNumber();
  }
  toString() {
    return this.asText();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
}
class r {
  constructor(e) {
    this.value = e;
  }
  asBoolean() {
    return this.value;
  }
  asNumber() {
    return this.value ? 1 : 0;
  }
  asText() {
    return this.value ? "true" : "false";
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
  equals(e) {
    return e.hasValue() && this.value === e.asBoolean();
  }
  toString() {
    return this.asText();
  }
}
class a {
  asBoolean() {
    return !1;
  }
  asNumber() {
    return 0;
  }
  asText() {
    return "";
  }
  map(e) {
    return this;
  }
  hasValue() {
    return !1;
  }
  equals(e) {
    return !e.hasValue();
  }
  toString() {
    return this.asText();
  }
}
a.Instance = new a();
class n {
  static of(e) {
    return void 0 === e
      ? a.Instance
      : "string" == typeof e
      ? new t(e)
      : "number" == typeof e
      ? new s(e)
      : "boolean" == typeof e
      ? e
        ? n.True
        : n.False
      : void 0;
  }
}
(n.True = new r(!0)), (n.False = new r(!1)), (n.None = a.Instance);
class o extends n {
  constructor(e, t) {
    super(), (this.id = e), (this.value = t);
  }
  asBoolean() {
    return this.value.asBoolean();
  }
  asNumber() {
    return this.value.asNumber();
  }
  asText() {
    return this.value.asText();
  }
  hasValue() {
    return this.value.hasValue();
  }
  equals(e) {
    return this.value.equals(e);
  }
}
class i {
  static just(e) {
    return e instanceof n
      ? new i.StaticResolvable(e)
      : new i.StaticResolvable(n.of(e));
  }
  map(e) {
    return new i.MappedResolvable(this, e);
  }
}
(i.StaticResolvable = class extends i {
  constructor(e) {
    super(), (this.resolved = e);
  }
  resolve(e) {
    return this.resolved;
  }
  asFormula() {
    return this.resolved.asText();
  }
}),
  (i.MappedResolvable = class extends i {
    constructor(e, t) {
      super(), (this.resolvable = e), (this.mapFn = t);
    }
    resolve(e) {
      return this.mapFn(this.resolvable.resolve(e));
    }
    asFormula() {
      return this.resolvable.asFormula();
    }
  }),
  (i.True = new i.StaticResolvable(n.True)),
  (i.False = new i.StaticResolvable(n.False)),
  (i.None = new i.StaticResolvable(n.None));
class u {
  constructor(e, t) {
    (this.value = e), (this.name = t);
  }
  asBoolean() {
    return this.value.asBoolean();
  }
  asNumber() {
    return this.value.asNumber();
  }
  asText() {
    return this.value.asText();
  }
  asName() {
    return this.name;
  }
  map(e) {
    return e(this);
  }
  equals(e) {
    return this.value.equals(e);
  }
  hasValue() {
    return this.value.hasValue();
  }
}
class h {
  constructor(e, t, s) {
    (this.value = e), (this.prefix = t), (this.suffix = s);
  }
  asBoolean() {
    return this.value.asBoolean();
  }
  asNumber() {
    return this.value.asNumber();
  }
  asText() {
    return this.value.asText();
  }
  asQuotedText() {
    return this.prefix + this.asText() + this.suffix;
  }
  map(e) {
    return e(this);
  }
  equals(e) {
    return this.value.equals(e);
  }
  hasValue() {
    return this.value.hasValue();
  }
}
class c {
  static of(e) {
    return new m(e);
  }
}
class l {
  static of(e) {
    return new d(e);
  }
}
l.Empty = new (class {
  get(e) {}
  resolve(e) {}
  keys() {
    return [];
  }
  search(e) {
    return [];
  }
})();
class p {
  resolve(e) {
    var t;
    return null === (t = this.get(e)) || void 0 === t
      ? void 0
      : t.resolve(this);
  }
  search(e) {
    return f.find(this, e);
  }
}
class f {
  static find(e, t) {
    const s = new RegExp(this.escapeRegExp(t).replace(/\\\*/g, ".*?"));
    return e
      .keys()
      .filter((e) => s.test(e))
      .map((t) => {
        const s = e.resolve(t);
        if (void 0 !== s) return new o(t, s);
      })
      .filter((e) => void 0 !== e)
      .map((e) => e);
  }
  static escapeRegExp(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
}
class d extends p {
  constructor(e) {
    super(), (this.state = e);
  }
  get(e) {
    const t = this.state[e];
    return t instanceof i ? t : i.just(t);
  }
  resolve(e) {
    const t = this.state[e];
    return t instanceof i ? t.resolve(this) : n.of(t);
  }
  set(e, t) {
    this.state[e] = t;
  }
  remove(e) {
    delete this.state[e];
  }
  keys() {
    return Object.keys(this.state);
  }
  rename(e, t) {
    e in this.state && ((this.state[t] = this.state[e]), delete this.state[e]);
  }
}
class m extends p {
  constructor(e = {}) {
    super(), (this.state = e);
  }
  get(e) {
    const t = this.state[e];
    return t instanceof i ? t : i.just(t);
  }
  resolve(e) {
    const t = this.state[e];
    return t instanceof i ? t.resolve(this) : n.of(t);
  }
  replace(e, t) {
    return new m(Object.assign(Object.assign({}, this.state), { [e]: t }));
  }
  keys() {
    return Object.keys(this.state);
  }
}
const v = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
  w = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
  ],
  b = [...[...w, ...v], "_"];
class x extends Error {
  constructor(e) {
    super(e);
  }
}
class g {
  constructor() {
    this.root = new B();
  }
  ignoreWhitespaces() {
    return this.add(" ", (e) => {});
  }
  add(e, t) {
    return "string" != typeof e
      ? ((s = e), (e = Array.isArray(s) ? s : [s]), this.addBranch(e, t))
      : this.addBranch([A(e)], t);
    var s;
  }
  addBranch(e, t) {
    return k.of(e).chainTo(this.root, t), this;
  }
  parse(e) {
    const t = [];
    for (let s = 0; s < e.length; s++) {
      const r = this.root.walk(e, s);
      if (!(r.length > 0))
        throw new x(
          g.generateParseErrorMessage(
            s,
            e,
            `did not expect character: '${e[s]}'`
          )
        );
      {
        const e = r[0],
          a = e.get();
        void 0 !== a && t.push(a), (s = e.endIndex - 1);
      }
    }
    return t;
  }
  static generateParseErrorMessage(e, t, s) {
    let r = `Parse error at index ${e} of "${t}": ${s}`;
    return (r += `\n${t}\n${" ".repeat(e)}^`), r;
  }
}
class N {
  constructor(e, t, s, r) {
    (this.text = e),
      (this.startIndex = t),
      (this.endIndex = s),
      (this.mapper = r);
  }
  get() {
    return this.mapper(this.text.substring(this.startIndex, this.endIndex));
  }
}
class L {
  static match(e) {
    return new T(e);
  }
}
class T extends L {
  constructor(e) {
    super(), (this.matcher = e);
  }
  node() {
    return new S(this.matcher);
  }
  repeats(e = 0, t = undefined) {
    return new $(this.matcher, e, t);
  }
  optional() {
    return this.repeats(0, 1);
  }
  not() {
    return new T(new C(this.matcher));
  }
}
class $ extends L {
  constructor(e, t, s) {
    super(), (this.matcher = e), (this.minLength = t), (this.maxLength = s);
  }
  node() {
    return new E(this.matcher, this.minLength, this.maxLength);
  }
}
class q extends L {
  constructor(e, t) {
    super(), (this.closeSequence = e), (this.escapeSequence = t);
  }
  node() {
    return new M(this.closeSequence, this.escapeSequence);
  }
}
class k {
  static of(e) {
    return new k(e);
  }
  constructor(e) {
    this.expressions = e;
  }
  chainTo(e, t, s = !0) {
    let r = e;
    for (let e of this.expressions)
      r = e instanceof L ? r.add(e.node()) : e.chainTo(r, t, !1);
    if (s) {
      let e = r;
      if (void 0 !== e.mapper) throw new Error("Conflicting tokens");
      e.mapper = t;
    }
    return r;
  }
}
class y {
  static of(e) {
    return new y(e);
  }
  constructor(e) {
    this.expressions = e;
  }
  chainTo(e, t, s = !0) {
    let r = e;
    r.mapper = t;
    for (let e of this.expressions)
      r = e instanceof F ? r.add(e) : e.chainTo(r, t, !1);
    if (s) {
      let e = r;
      if (void 0 !== e.mapper) throw new Error("Conflicting tokens");
      e.mapper = t;
    }
    return r;
  }
}
class F {
  constructor() {
    (this.id = F.idCounter++), (this.children = void 0);
  }
  add(e) {
    void 0 === this.children && (this.children = []);
    for (let t of this.children) if (t.equals(e)) return t;
    return this.children.push(e), e;
  }
  walkChildren(e, t, s) {
    return void 0 === this.children
      ? []
      : this.children.flatMap((r) => r.walk(e, t, s));
  }
}
F.idCounter = 1;
class B extends F {
  walk(e, t = 0, s = t) {
    return this.walkChildren(e, t, s);
  }
  equals(e) {
    return !1;
  }
}
class S extends F {
  constructor(e) {
    super(), (this.matcher = e), (this.mapper = void 0);
  }
  walk(e, t, s) {
    if (!this.matches(e, t, s)) return [];
    const r = this.walkChildren(e, t, s + 1);
    return r.length > 0
      ? r
      : void 0 !== this.mapper
      ? [new N(e, t, s + 1, this.mapper)]
      : [];
  }
  matches(e, t, s) {
    const r = e[s];
    return void 0 !== r && this.matcher.matches(r);
  }
  equals(e) {
    return e instanceof S && this.matcher.equals(e.matcher);
  }
}
class E extends F {
  constructor(e, t, s) {
    super(),
      (this.matcher = e),
      (this.minLength = t),
      (this.maxLength = s),
      (this.mapper = void 0);
  }
  walk(e, t, s) {
    const r = this.minLength,
      a = this.calculateMaxLength(e, s);
    let n = 0;
    for (
      let t = e[s];
      void 0 !== t && this.matcher.matches(t) && n < a;
      t = e[s]
    )
      s++, n++;
    if (n < r) return [];
    const o = this.walkChildren(e, t, s);
    return n > a || o.length > 0
      ? o
      : void 0 !== this.mapper
      ? [new N(e, t, s, this.mapper)]
      : [];
  }
  equals(e) {
    return (
      e instanceof E &&
      this.matcher.equals(e.matcher) &&
      this.minLength === e.minLength &&
      this.maxLength === e.maxLength
    );
  }
  calculateMaxLength(e, t) {
    const s = e.length - t;
    return void 0 !== this.maxLength ? Math.min(this.maxLength, s) : s;
  }
}
class M extends F {
  constructor(e, t) {
    super(),
      (this.closeSequence = e),
      (this.escapeSequence = t),
      (this.mapper = void 0);
  }
  walk(e, t, s) {
    for (; s < e.length; s++)
      for (
        let r = 0;
        r < this.closeSequence.length &&
        e[s + r] === this.closeSequence[r] &&
        !this.isEscaped(e, s);
        r++
      )
        if (r === this.closeSequence.length - 1) {
          const r = this.walkChildren(e, t, s);
          return r.length > 0
            ? r
            : void 0 !== this.mapper && s > t
            ? [new N(e, t, s, this.mapper)]
            : [];
        }
    return void 0 !== this.mapper && s === e.length
      ? [new N(e, t, s, this.mapper)]
      : [];
  }
  isEscaped(e, t) {
    if (void 0 === this.escapeSequence) return !1;
    for (
      let s = t - this.escapeSequence.length + 1, r = 0;
      r < this.escapeSequence.length;
      s++, r++
    ) {
      if (s < 0 && s >= t) return !1;
      if (e[s] !== this.escapeSequence[r]) return !1;
    }
    return !0;
  }
  equals(e) {
    return e instanceof M && this.closeSequence === e.closeSequence;
  }
}
class R {
  constructor(e) {
    this.character = e;
  }
  matches(e) {
    return this.character === e;
  }
  equals(e) {
    return e instanceof R && this.character === e.character;
  }
}
class V {
  constructor(e) {
    this.allowed = e;
  }
  matches(e) {
    return this.allowed.includes(e);
  }
  equals(e) {
    return (
      e instanceof V &&
      (function (e, t) {
        if (e.length !== t.length) return !1;
        for (let s = 0; s < e.length; s++) if (e[s] !== t[s]) return !1;
        return !0;
      })(this.allowed, e.allowed)
    );
  }
}
class I {
  matches(e) {
    return void 0 !== e;
  }
  equals(e) {
    return e instanceof V;
  }
}
class C {
  constructor(e) {
    this.matcher = e;
  }
  matches(e) {
    return !this.matcher.matches(e);
  }
  equals(e) {
    return e instanceof C && this.matcher.equals(e.matcher);
  }
}
function j(e) {
  return (
    Array.isArray(e) && 1 === e.length && (e = e[0]),
    L.match(Array.isArray(e) ? new V(e) : new R(e))
  );
}
function A(e) {
  return k.of(Array.from(e).map((e) => j(e)));
}
function O(...e) {
  return k.of(e.map((e) => ("string" == typeof e ? A(e) : e)));
}
function P(...e) {
  return y.of([O(...e)]);
}
function U(e, t, s = undefined) {
  return O(
    A(e),
    (function (e, t = undefined) {
      return O(new q(e, t));
    })(t, s),
    A(t)
  );
}
new (class extends L {
  constructor() {
    super(), (this.matcher = new I());
  }
  node() {
    return new S(this.matcher);
  }
  except(...e) {
    return new T(new C(new V(e)));
  }
  repeats(e = 0, t = undefined) {
    return new $(this.matcher, e, t);
  }
  optional() {
    return this.repeats(0, 1);
  }
  not() {
    return new T(new C(this.matcher));
  }
})();
const z = O(j(v).repeats(1));
O(j(b).repeats(1));
const D = O(j([...b, ":", ".", "#", "*"]).repeats(1)),
  Q = O(z),
  W = O(Q, ".", z);
O(Q, P(".", z));
const G = j(w);
function H(e, t) {
  switch (e) {
    case 0:
      return () => n.of(t());
    case 1:
      return (e) => {
        var s;
        return n.of(
          t(
            null !== (s = null == e ? void 0 : e.asNumber()) && void 0 !== s
              ? s
              : 0
          )
        );
      };
    case 2:
      return (e, s) => {
        var r, a;
        return n.of(
          t(
            null !== (r = null == e ? void 0 : e.asNumber()) && void 0 !== r
              ? r
              : 0,
            null !== (a = null == s ? void 0 : s.asNumber()) && void 0 !== a
              ? a
              : 0
          )
        );
      };
    case 3:
      return (e, s, r) => {
        var a, o, i;
        return n.of(
          t(
            null !== (a = null == e ? void 0 : e.asNumber()) && void 0 !== a
              ? a
              : 0,
            null !== (o = null == s ? void 0 : s.asNumber()) && void 0 !== o
              ? o
              : 0,
            null !== (i = null == r ? void 0 : r.asNumber()) && void 0 !== i
              ? i
              : 0
          )
        );
      };
    default:
      throw new Error(`Unsupported number of operands: ${e}`);
  }
}
var J;
!(function (e) {
  (e[(e.Left = 1)] = "Left"), (e[(e.Right = 2)] = "Right");
})(J || (J = {}));
class K {
  constructor(e, t, s) {
    (this.name = e), (this.operands = t), (this.fn = s);
  }
  execute(e, t, s) {
    switch (this.operands) {
      case 0:
        return this.fn();
      case 1:
        return this.fn(e);
      case 2:
        return this.fn(e, t);
      case 3:
        return this.fn(e, t, s);
      default:
        throw new Error(`Unsupported number of operands: ${this.operands}`);
    }
  }
}
class X extends K {
  constructor(e, t, s) {
    super(e, t, s);
  }
}
class Y {
  constructor(e, t) {
    (this.name = e), (this.fn = t);
  }
  execute(e) {
    return this.fn(e);
  }
}
class Z extends K {
  constructor(e, t, s, r, a) {
    super(e, r, a),
      (this.name = e),
      (this.precedence = t),
      (this.associativity = s);
  }
}
class _ {
  constructor(e, t) {
    (this.unary = e), (this.binary = t);
  }
}
class ee {
  constructor(e, t) {
    (this.key = e), (this.resolver = t);
  }
  resolve(e) {
    var t;
    return null !== (t = this.resolver(e, this.key)) && void 0 !== t
      ? t
      : n.None;
  }
  toString() {
    return this.key;
  }
}
class te {
  constructor(e, t) {
    (this.text = e), (this.decorator = t);
  }
  apply(e) {
    return this.decorator(this.text, e);
  }
}
class se {
  constructor(e, t = undefined, s = undefined) {
    (this.resolver = e), (this.prefix = t), (this.suffix = s);
  }
  resolve(e) {
    return this.prefix && this.suffix
      ? this.resolver(e).map((e) => new h(e, this.prefix, this.suffix))
      : this.resolver(e);
  }
}
class re {
  constructor() {
    (this.bracketFn = (e) => e),
      (this.parser = new g()
        .ignoreWhitespaces()
        .add([Q], (e) => parseInt(e))
        .add([W], (e) => parseFloat(e))
        .add("(", (e) => e)
        .add(")", (e) => e)
        .add(",", (e) => e)
        .add(
          U('"', '"', '\\"'),
          (e) => new se(() => n.of(e.slice(1, -1)), '"', '"')
        )
        .add(
          U("'", "'", "\\'"),
          (e) => new se(() => n.of(e.slice(1, -1)), "'", "'")
        ));
  }
  operator(e, t, s, r, a) {
    return this.parser.add(e, (n) => new Z(e, t, s, r, a)), this;
  }
  biOperator(e, t, s, r, a, n, o) {
    return (
      this.parser.add(
        e,
        (i) => new _(new Z(e, t, s, 1, r), new Z(e, a, n, 2, o))
      ),
      this
    );
  }
  intOperator(e, t, s, r, a) {
    return this.operator(e, t, s, r, H(r, a));
  }
  function(e, t, s) {
    return this.parser.add(e, (r) => new X(e, t, s)), this;
  }
  varargsFunction(e, t) {
    return this.parser.add(e, (s) => new Y(e, t)), this;
  }
  intFunction(e, t, s) {
    return this.function(e, t, H(t, s));
  }
  variable(e, t, s) {
    return (
      this.parser.add(
        [A(e), G, P(D), A(t)],
        (r) =>
          new ee(r, (r, a) => s(r, a.substring(e.length, a.length - t.length)))
      ),
      this
    );
  }
  comment(e, t, s = (e, t) => t) {
    return (
      this.parser.add(
        U(e, t),
        (r) => new te(r.substring(e.length, r.length - t.length), s)
      ),
      this
    );
  }
  term(e, t) {
    return this.parser.add([A(e)], (e) => new ee(e, (e) => t(e))), this;
  }
  brackets(e) {
    return (this.bracketFn = e), this;
  }
  parse(e) {
    let t = [],
      s = [],
      r = [];
    const a = this.parser.parse(e);
    for (let e = 0; e < a.length; e++) {
      let o = a[e],
        i = e > 0 ? a[e - 1] : void 0;
      if (o instanceof _) {
        let e = o;
        (o = e.binary),
          (!i || i instanceof Z || "(" === i || "," === i) && (o = e.unary);
      }
      if (o instanceof Z) {
        let e = o,
          r = s.at(-1);
        r instanceof Z &&
          (e.precedence < r.precedence ||
            (e.associativity === J.Left && e.precedence === r.precedence)) &&
          (s.pop(), t.push(r)),
          s.push(e);
      } else if (o instanceof X) s.push(o), r.push(1);
      else if (o instanceof Y) s.push(o), r.push(1);
      else if (o instanceof ee) t.push(o);
      else if (o instanceof se) t.push(o);
      else if (o instanceof te) t.push(o);
      else
        switch (o) {
          case " ":
          case "{":
          case "}":
            break;
          case ",":
            for (r[r.length - 1]++; s.length > 0; ) {
              let e = s.pop();
              if ("(" === e) {
                s.push(e);
                break;
              }
              t.push(e);
            }
            break;
          case "(":
            s.push(o);
            break;
          case ")":
            for (; s.length > 0; ) {
              let e = s.pop();
              if ("(" === e) break;
              t.push(e);
            }
            if (s.at(-1) instanceof X) {
              const e = r.pop(),
                a = s.pop();
              if (e !== a.operands)
                throw new Error(
                  `${a.name} expected ${a.operands} parameters, but got ${e}`
                );
              t.push(a);
            } else if (s.at(-1) instanceof Y) {
              let e = r.pop();
              (e = "(" === i ? 0 : e), t.push(e), t.push(s.pop());
            }
            break;
          default:
            t.push(n.of(o));
        }
    }
    for (; s.length > 0; ) t.push(s.pop());
    return new ae(t, e);
  }
}
class ae extends i {
  static parser() {
    return new re();
  }
  constructor(e, t) {
    super(), (this.stack = e), (this.originalFormula = t);
  }
  asFormula() {
    return this.originalFormula;
  }
  resolve(t = l.Empty) {
    let s = [],
      r = [...this.stack];
    for (; r.length > 0; ) {
      let a = r.shift();
      if (a instanceof K) {
        let t = a;
        if (0 === t.operands) s.push(t.execute());
        else if (1 === t.operands) {
          let r = s.pop();
          if (void 0 === r) throw new e(`Missing parameter #1 for "${t.name}"`);
          s.push(t.execute(r));
        } else if (2 === t.operands) {
          let r = s.pop(),
            a = s.pop();
          if (void 0 === r) throw new e(`Missing parameter #1 for "${t.name}"`);
          if (void 0 === a) throw new e(`Missing parameter #2 for "${t.name}"`);
          s.push(t.execute(a, r));
        } else {
          if (3 !== t.operands)
            throw new Error("Unsupported number of operands: " + t.operands);
          {
            let r = s.pop(),
              a = s.pop(),
              n = s.pop();
            if (void 0 === r)
              throw new e(`Missing parameter #1 for "${t.name}"`);
            if (void 0 === a)
              throw new e(`Missing parameter #2 for "${t.name}"`);
            if (void 0 === n)
              throw new e(`Missing parameter #3 for "${t.name}"`);
            s.push(t.execute(n, a, r));
          }
        }
      } else if (a instanceof Y) {
        let e = a,
          t = [],
          r = s.pop();
        for (; r-- > 0; ) t.push(s.pop());
        s.push(e.execute(t));
      } else if (a instanceof te) {
        const e = s.pop();
        s.push(a.apply(e));
      } else if (
        (a instanceof se && (a = a.resolve(t)),
        a instanceof ee && ((a = a.resolve(t)), a instanceof ae))
      ) {
        const e = a.stack;
        for (let t = e.length - 1; t >= 0; t--) r.unshift(e[t]);
      } else {
        for (; a instanceof i; ) a = a.resolve(t);
        s.push(a);
      }
    }
    return s.pop();
  }
}
function ne(e) {
  return (...t) => n.of(e(...t.map(ie)));
}
function oe(e) {
  return (...t) => n.of(`${e}(${t.map(ie).join(",")})`);
}
function ie(e) {
  return e instanceof h ? e.asQuotedText() : e.asText();
}
class ue extends n {
  asNumber() {
    throw ue.UnsupportedException;
  }
  asBoolean() {
    throw ue.UnsupportedException;
  }
}
ue.UnsupportedException = new Error("Not available for optimization");
class he extends ue {
  constructor(e) {
    super(), (this.values = []);
    let t = !1,
      s = !1;
    e.forEach((e) => {
      e instanceof he
        ? this.values.unshift(...e.values)
        : e !== n.False
        ? e !== n.True
          ? this.values.unshift(e)
          : (t = !0)
        : (s = !0);
    }),
      t && (this.values = [n.True]),
      0 === this.values.length && (this.values = [s ? n.False : n.True]);
  }
  asText() {
    return 1 === this.values.length
      ? ie(this.values[0])
      : `any(${this.values.map(ie).join(",")})`;
  }
}
class ce extends ue {
  constructor(e) {
    super(), (this.values = []);
    let t = !1;
    e.forEach((e) => {
      e instanceof ce
        ? this.values.unshift(...e.values)
        : e !== n.True && (e !== n.False ? this.values.unshift(e) : (t = !0));
    }),
      t && (this.values = [n.False]),
      0 === this.values.length && (this.values = [n.True]);
  }
  asText() {
    return 1 === this.values.length
      ? ie(this.values[0])
      : `all(${this.values.map(ie).join(",")})`;
  }
}
class le extends ue {
  static create(e) {
    return (t, s) => new le(e, t, s);
  }
  constructor(e, t, s) {
    super(), (this.operator = e), (this.a = t), (this.b = s);
  }
  asText() {
    return `(${this.asTextNoBrackets()})`;
  }
  asTextNoBrackets() {
    return this.format(this.a) + this.operator + this.format(this.b);
  }
  format(e) {
    if (e instanceof le) {
      if (
        !(
          ("+" != e.operator && "-" != e.operator) ||
          ("+" != this.operator && "-" != this.operator)
        )
      )
        return e.asTextNoBrackets();
      if (
        !(
          ("*" != e.operator && "/" != e.operator) ||
          ("*" != this.operator && "/" != this.operator)
        )
      )
        return e.asTextNoBrackets();
    }
    return ie(e);
  }
}
class pe {
  static optimize(e) {
    const t = this.Parser.parse(e).resolve();
    return t instanceof le ? t.asTextNoBrackets() : ie(t);
  }
}
pe.Parser = ae
  .parser()
  .operator("^", 4, J.Right, 2, le.create("^"))
  .operator("*", 3, J.Left, 2, le.create("*"))
  .operator("/", 3, J.Left, 2, le.create("/"))
  .operator("+", 2, J.Left, 2, le.create("+"))
  .operator("-", 2, J.Left, 2, le.create("-"))
  .operator(
    "!",
    2,
    J.Left,
    1,
    ne((e) => `!${e}`)
  )
  .operator(
    "<",
    3,
    J.Left,
    2,
    ne((e, t) => `${e}<${t}`)
  )
  .operator(
    "<=",
    3,
    J.Left,
    2,
    ne((e, t) => `${e}<=${t}`)
  )
  .operator(
    ">",
    3,
    J.Left,
    2,
    ne((e, t) => `${e}>${t}`)
  )
  .operator(
    ">=",
    3,
    J.Left,
    2,
    ne((e, t) => `${e}>=${t}`)
  )
  .operator(
    "==",
    3,
    J.Left,
    2,
    ne((e, t) => `${e}==${t}`)
  )
  .operator(
    "!=",
    3,
    J.Left,
    2,
    ne((e, t) => `${e}!=${t}`)
  )
  .operator("AND", 1, J.Left, 2, (e, t) => new ce([t, e]))
  .operator("OR", 1, J.Left, 2, (e, t) => new he([t, e]))
  .term("true", () => n.of(!0))
  .term("false", () => n.of(!1))
  .term("null", () => n.of("null"))
  .function("abs", 1, oe("abs"))
  .function("min", 2, oe("min"))
  .function("max", 2, oe("max"))
  .function("floor", 1, oe("floor"))
  .function("ceil", 1, oe("ceil"))
  .function("signed", 1, oe("signed"))
  .function("if", 3, oe("if"))
  .function("concat", 2, oe("concat"))
  .function("ordinal", 1, oe("ordinal"))
  .varargsFunction("any", (e) => new he(e))
  .varargsFunction("all", (e) => new ce(e))
  .variable("@", "", (e, t) => n.of(`@${t}`))
  .variable("@{", "}", (e, t) => n.of(`@{${t}}`))
  .variable("min(@", ")", (e, t) => n.of(`min(@${t})`))
  .variable("max(@", ")", (e, t) => n.of(`max(@${t})`))
  .variable("sum(@", ")", (e, t) => n.of(`sum(@${t})`))
  .comment("[", "]", (e, t) => new h(t, "", `[${e}]`));
class fe {
  static parse(e) {
    return e instanceof i ? e : this.Parser.parse(e);
  }
  static optimize(e) {
    return pe.optimize(e);
  }
  static noneIfEmpty(e) {
    return e.length > 0 ? e : [];
  }
  static variableFn(e, t) {
    return e.get(t);
  }
  static minFn(e, t) {
    return fe
      .noneIfEmpty(e.search(t))
      .reduce((e, t) => (e.asNumber() < t.asNumber() ? e : t));
  }
  static maxFn(e, t) {
    return fe
      .noneIfEmpty(e.search(t))
      .reduce((e, t) => (e.asNumber() > t.asNumber() ? e : t), n.None);
  }
  static sumFn(e, t) {
    return e.search(t).reduce((e, t) => fe.addFn(e, t), n.None);
  }
  static addFn(e, t) {
    return (null != e ? e : n.None).equals(n.None) &&
      (null != t ? t : n.None).equals(n.None)
      ? n.None
      : n.of(e.asNumber() + t.asNumber());
  }
}
fe.Parser = ae
  .parser()
  .biOperator(
    "-",
    4,
    J.Left,
    (e) => n.of(-e.asNumber()),
    2,
    J.Left,
    (e, t) => n.of(e.asNumber() - t.asNumber())
  )
  .operator("^", 4, J.Right, 2, (e, t) =>
    n.of(Math.pow(e.asNumber(), t.asNumber()))
  )
  .operator("*", 3, J.Left, 2, (e, t) => n.of(e.asNumber() * t.asNumber()))
  .operator("/", 3, J.Left, 2, (e, t) => n.of(e.asNumber() / t.asNumber()))
  .operator("+", 2, J.Left, 2, fe.addFn)
  .operator("!", 2, J.Left, 1, (e) => n.of(!e.asBoolean()))
  .operator("<", 3, J.Left, 2, (e, t) => n.of(e.asNumber() < t.asNumber()))
  .operator("<=", 3, J.Left, 2, (e, t) => n.of(e.asNumber() <= t.asNumber()))
  .operator(">", 3, J.Left, 2, (e, t) => n.of(e.asNumber() > t.asNumber()))
  .operator(">=", 3, J.Left, 2, (e, t) => n.of(e.asNumber() >= t.asNumber()))
  .operator("==", 3, J.Left, 2, (e, t) => n.of(e.equals(t)))
  .operator("!=", 3, J.Left, 2, (e, t) => n.of(!e.equals(t)))
  .operator("AND", 1, J.Left, 2, (e, t) => n.of(e.asBoolean() && t.asBoolean()))
  .operator("OR", 1, J.Left, 2, (e, t) => n.of(e.asBoolean() || t.asBoolean()))
  .term("true", () => n.of(!0))
  .term("false", () => n.of(!1))
  .term("null", () => n.None)
  .function("abs", 1, (e) => n.of(Math.abs(e.asNumber())))
  .function("min", 2, (e, t) => n.of(Math.min(e.asNumber(), t.asNumber())))
  .function("max", 2, (e, t) => n.of(Math.max(e.asNumber(), t.asNumber())))
  .function("floor", 1, (e) => n.of(Math.floor(e.asNumber())))
  .function("ceil", 1, (e) => n.of(Math.ceil(e.asNumber())))
  .function("signed", 1, (e) =>
    n.of((e.asNumber() < 0 ? "" : "+") + e.asNumber())
  )
  .function("if", 3, (e, t, s) => (e.asBoolean() ? t : s))
  .function("concat", 2, (e, t) => n.of(e.asText() + t.asText()))
  .function("ordinal", 1, (e) =>
    n.of(
      (function (e) {
        let t = ["th", "st", "nd", "rd"],
          s = e % 100;
        return e + (t[(s - 20) % 10] || t[s] || t[0]);
      })(e.asNumber())
    )
  )
  .varargsFunction("any", (e) => n.of(e.some((e) => e.asBoolean())))
  .varargsFunction("all", (e) => n.of(e.every((e) => e.asBoolean())))
  .variable("@", "", fe.variableFn)
  .variable("@{", "}", fe.variableFn)
  .variable("min(@", ")", fe.minFn)
  .variable("max(@", ")", fe.maxFn)
  .variable("sum(@", ")", fe.sumFn)
  .comment("[", "]", (e, t) => new u(t, e));
export {
  J as Associativity,
  p as BaseDataContext,
  l as DataContext,
  fe as Formula,
  c as ImmutableDataContext,
  u as NamedResolvedValue,
  h as QuotedTextResolvedValue,
  i as Resolvable,
  e as ResolveError,
  n as ResolvedValue,
  o as ResolvedValueWithId,
  ae as ShuntingYard,
  re as ShuntingYardParser,
};
//# sourceMappingURL=index.esm.js.map
