import { DataContext } from "./DataContext";
import Parser from "./Parser";
import { Resolvable } from "./Resolvable";
import { ResolvedValue } from "./ResolvedValue";
type ZeroOperandFunction<T> = () => T;
type OneOperandFunction<T> = (x: T) => T;
type TwoOperandFunction<T> = (x: T, y: T) => T;
type ThreeOperandFunction<T> = (x: T, y: T, z: T) => T;
type OperandFunction<T> =
  | ZeroOperandFunction<T>
  | OneOperandFunction<T>
  | TwoOperandFunction<T>
  | ThreeOperandFunction<T>;
type VarargsOperandFunction<T> = (n: T[]) => T;
export declare enum Associativity {
  Left = 1,
  Right = 2,
}
interface Node {}
export declare class ShuntingYardParser implements Parser {
  private readonly parser;
  private bracketFn;
  constructor();
  operator(
    symbol: string,
    precedence: number,
    associativity: Associativity,
    operands: number,
    fn: OperandFunction<ResolvedValue>
  ): this;
  biOperator(
    symbol: string,
    unaryPrecedence: number,
    unaryAssociativity: Associativity,
    unaryFn: OneOperandFunction<ResolvedValue>,
    binaryPrecedence: number,
    binaryAssociativity: Associativity,
    binaryFn: TwoOperandFunction<ResolvedValue>
  ): this;
  intOperator(
    symbol: string,
    precedence: number,
    associativity: Associativity,
    operands: number,
    fn: OperandFunction<number>
  ): this;
  function(
    name: string,
    operands: number,
    fn: OperandFunction<ResolvedValue>
  ): this;
  varargsFunction(
    name: string,
    fn: VarargsOperandFunction<ResolvedValue>
  ): this;
  intFunction(
    name: string,
    operands: number,
    fn: OperandFunction<number>
  ): this;
  variable(
    prefix: string,
    suffix: string,
    extractor: (context: DataContext, key: string) => ResolvedValue | Resolvable
  ): this;
  comment(
    prefix: string,
    suffix: string,
    decorator?: (text: string, value: ResolvedValue) => ResolvedValue
  ): this;
  term(
    text: string,
    extractor: (context: DataContext) => ResolvedValue | Resolvable | undefined
  ): this;
  brackets(mapFn: (value: ResolvedValue) => ResolvedValue): this;
  parse(formula: string): ShuntingYard;
}
type OperatorStack = Array<Node | string | number | null | undefined>;
export declare class ShuntingYard extends Resolvable {
  private readonly originalFormula;
  private readonly stack;
  static parser(): ShuntingYardParser;
  constructor(stack: OperatorStack, originalFormula: string);
  asFormula(): string;
  resolve(context?: DataContext): ResolvedValue | undefined;
}
export {};
