export declare class ParseError extends Error {
  constructor(message: string);
}
export type TokenMapper = (token: string) => any;
export default class TokenTree {
  private readonly root;
  ignoreWhitespaces(): TokenTree;
  add(
    matchers:
      | string
      | NodeFactory
      | NodeExpression
      | Array<NodeFactory | NodeExpression>,
    mapper: TokenMapper
  ): TokenTree;
  private addBranch;
  parse(text: string): any[];
  private static generateParseErrorMessage;
}
declare class TokenMatch {
  readonly text: string;
  readonly startIndex: number;
  readonly endIndex: number;
  readonly mapper: TokenMapper;
  constructor(
    text: string,
    startIndex: number,
    endIndex: number,
    mapper: TokenMapper
  );
  get(): any;
}
declare abstract class NodeFactory {
  static match(matcher: TokenMatcher): MatcherNodeFactory;
  abstract node(): Node;
}
declare class MatcherNodeFactory extends NodeFactory {
  private readonly matcher;
  constructor(matcher: TokenMatcher);
  node(): Node;
  repeats(
    minLength?: number,
    maxLength?: number | undefined
  ): RepeatingNodeFactory;
  optional(): RepeatingNodeFactory;
  not(): MatcherNodeFactory;
}
declare class AnyMatcherNodeFactory extends NodeFactory {
  private readonly matcher;
  constructor();
  node(): Node;
  except(...notAllowed: string[]): MatcherNodeFactory;
  repeats(
    minLength?: number,
    maxLength?: number | undefined
  ): RepeatingNodeFactory;
  optional(): RepeatingNodeFactory;
  not(): MatcherNodeFactory;
}
declare class RepeatingNodeFactory extends NodeFactory {
  private readonly matcher;
  private readonly minLength;
  private readonly maxLength;
  constructor(
    matcher: TokenMatcher,
    minLength: number,
    maxLength: number | undefined
  );
  node(): Node;
}
export interface NodeExpression {
  chainTo(root: Node, mapper: TokenMapper, isRoot: boolean): Node;
}
export declare abstract class Node {
  static idCounter: number;
  id: number;
  protected children: Node[] | undefined;
  add(child: Node): Node;
  abstract walk(
    text: string,
    startIndex: number,
    currentIndex: number
  ): TokenMatch[];
  protected walkChildren(
    text: string,
    startIndex: number,
    currentIndex: number
  ): TokenMatch[];
  abstract equals(node: Node): boolean;
}
interface TokenMatcher {
  matches(character: string): boolean;
  equals(other: TokenMatcher): boolean;
}
export declare function anyof(allowed: string | string[]): MatcherNodeFactory;
export declare function term(text: string): NodeExpression;
export declare function just(
  ...expressions: Array<string | NodeFactory | NodeExpression>
): NodeExpression;
export declare function optional(
  ...expressions: Array<string | NodeFactory | NodeExpression>
): NodeExpression;
export declare function literal(
  openSequence: string,
  closeSequence: string,
  escapeSequence?: string | undefined
): NodeExpression;
export declare function anyUntil(
  closeSequence: string,
  escapeSequence?: string | undefined
): NodeExpression;
export declare const any: AnyMatcherNodeFactory;
export declare const digit: MatcherNodeFactory;
export declare const digits: NodeExpression;
export declare const words: NodeExpression;
export declare const key: NodeExpression;
export declare const integer: NodeExpression;
export declare const decimal: NodeExpression;
export declare const number: NodeExpression;
export declare const alpha: MatcherNodeFactory;
export {};
