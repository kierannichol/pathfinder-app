class e extends Error {
  constructor(e) {
    super(e);
  }
}
class t {
  constructor(e) {
    this.values = e;
  }
  asText() {
    return this.latest().asText();
  }
  asNumber() {
    return this.latest().asNumber();
  }
  asBoolean() {
    return this.latest().asBoolean();
  }
  asList() {
    return this.values;
  }
  equals(e) {
    const t = e.asList();
    if (t.length !== this.values.length) return !1;
    for (let e = 0; e < this.values.length; e++)
      if (!this.values[e].equals(t[e])) return !1;
    return !0;
  }
  toString() {
    return this.values.toString();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
  latest() {
    return 0 == this.values.length
      ? i.None
      : this.values[this.values.length - 1];
  }
}
class s {
  constructor(e) {
    this.value = e;
  }
  asText() {
    return this.value;
  }
  asNumber() {
    let t = parseFloat(this.value);
    if (Number.isNaN(t))
      throw new e(`Cannot convert '${this.value}' to a number`);
    return t;
  }
  asBoolean() {
    return !["false", "no", "0", ""].includes(this.value.toLowerCase());
  }
  asList() {
    return [this];
  }
  equals(e) {
    return e.hasValue() && this.value === e.asText();
  }
  toString() {
    return this.asText();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
}
class r {
  constructor(e) {
    this.value = e;
  }
  asText() {
    return this.value.toString();
  }
  asNumber() {
    return this.value;
  }
  asBoolean() {
    return this.value > 0;
  }
  asList() {
    return [this];
  }
  equals(e) {
    return e.hasValue() && this.value === e.asNumber();
  }
  toString() {
    return this.asText();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
}
class a {
  constructor(e) {
    this.value = e;
  }
  asBoolean() {
    return this.value;
  }
  asNumber() {
    return this.value ? 1 : 0;
  }
  asText() {
    return this.value ? "true" : "false";
  }
  asList() {
    return [this];
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
  equals(e) {
    return e.hasValue() && this.value === e.asBoolean();
  }
  toString() {
    return this.asText();
  }
}
class n {
  asBoolean() {
    return !1;
  }
  asNumber() {
    return 0;
  }
  asText() {
    return "";
  }
  asList() {
    return [];
  }
  map(e) {
    return this;
  }
  hasValue() {
    return !1;
  }
  equals(e) {
    return !e.hasValue();
  }
  toString() {
    return this.asText();
  }
}
n.Instance = new n();
class i {
  static of(e) {
    return void 0 === e
      ? n.Instance
      : "string" == typeof e
      ? new s(e)
      : "number" == typeof e
      ? new r(e)
      : "boolean" == typeof e
      ? e
        ? i.True
        : i.False
      : Array.isArray(e)
      ? new t(e.map(i.of))
      : e;
  }
}
(i.True = new a(!0)), (i.False = new a(!1)), (i.None = n.Instance);
class o {
  constructor(e, t) {
    (this.id = e), (this.value = t);
  }
  asBoolean() {
    return this.value.asBoolean();
  }
  asNumber() {
    return this.value.asNumber();
  }
  asText() {
    return this.value.asText();
  }
  asList() {
    return this.value.asList();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return this.value.hasValue();
  }
  equals(e) {
    return this.value.equals(e);
  }
}
class u {
  static just(e) {
    return e instanceof i
      ? new u.StaticResolvable(e)
      : new u.StaticResolvable(i.of(e));
  }
  map(e) {
    return new u.MappedResolvable(this, e);
  }
}
(u.StaticResolvable = class extends u {
  constructor(e) {
    super(), (this.resolved = e);
  }
  resolve(e) {
    return this.resolved;
  }
  asFormula() {
    return this.resolved.asText();
  }
}),
  (u.MappedResolvable = class extends u {
    constructor(e, t) {
      super(), (this.resolvable = e), (this.mapFn = t);
    }
    resolve(e) {
      return this.mapFn(this.resolvable.resolve(e));
    }
    asFormula() {
      return this.resolvable.asFormula();
    }
  }),
  (u.True = new u.StaticResolvable(i.True)),
  (u.False = new u.StaticResolvable(i.False)),
  (u.None = new u.StaticResolvable(i.None));
class h {
  constructor(e, t) {
    (this.value = e), (this.name = t);
  }
  asBoolean() {
    return this.value.asBoolean();
  }
  asNumber() {
    return this.value.asNumber();
  }
  asText() {
    return this.value.asText();
  }
  asList() {
    return this.value.asList();
  }
  asName() {
    return this.name;
  }
  map(e) {
    return e(this);
  }
  equals(e) {
    return this.value.equals(e);
  }
  hasValue() {
    return this.value.hasValue();
  }
}
class c {
  constructor(e, t, s) {
    (this.value = e), (this.prefix = t), (this.suffix = s);
  }
  asBoolean() {
    return this.value.asBoolean();
  }
  asNumber() {
    return this.value.asNumber();
  }
  asText() {
    return this.value.asText();
  }
  asList() {
    return this.value.asList();
  }
  asQuotedText() {
    return this.prefix + this.asText() + this.suffix;
  }
  map(e) {
    return e(this);
  }
  equals(e) {
    return this.value.equals(e);
  }
  hasValue() {
    return this.value.hasValue();
  }
}
class l {
  static of(e) {
    return new v(e);
  }
}
class p {
  static of(e) {
    return new m(e);
  }
}
p.Empty = new (class {
  get(e) {}
  keys() {
    return [];
  }
  search(e) {
    return [];
  }
})();
class f {
  search(e) {
    return d.find(this, e);
  }
}
class d {
  static find(e, t) {
    if (!t.includes("*")) return [new o(t, e.get(t))];
    const s = new RegExp(
      "^" + this.escapeRegExp(t).replace(/\\\*/g, ".*?") + "$"
    );
    return e
      .keys()
      .filter((e) => s.test(e))
      .map((t) => {
        const s = e.get(t);
        if (void 0 !== s) return new o(t, s);
      })
      .filter((e) => void 0 !== e)
      .map((e) => e);
  }
  static escapeRegExp(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
}
class m extends f {
  constructor(e) {
    super(), (this.state = e);
  }
  get(e) {
    const s = this.state[e];
    return s instanceof u
      ? s.resolve(this)
      : Array.isArray(s)
      ? new t(s.map((e) => (e instanceof u ? e.resolve(this) : i.of(e))))
      : i.of(s);
  }
  set(e, t) {
    this.state[e] = t;
  }
  push(e, t) {
    const s = this.state[e];
    void 0 === s
      ? (this.state[e] = [t])
      : Array.isArray(s)
      ? s.push(t)
      : (this.state[e] = [s, t]);
  }
  remove(e) {
    delete this.state[e];
  }
  keys() {
    return Object.keys(this.state);
  }
  rename(e, t) {
    e in this.state && ((this.state[t] = this.state[e]), delete this.state[e]);
  }
}
class v extends f {
  constructor(e = {}) {
    super(), (this.state = e);
  }
  get(e) {
    const s = this.state[e];
    return s instanceof u
      ? s.resolve(this)
      : Array.isArray(s)
      ? new t(s.map((e) => (e instanceof u ? e.resolve(this) : i.of(e))))
      : i.of(s);
  }
  replace(e, t) {
    return new v(Object.assign(Object.assign({}, this.state), { [e]: t }));
  }
  remove(e) {
    const t = Object.assign({}, this.state);
    return delete t[e], new v(t);
  }
  rename(e, t) {
    const s = Object.assign({}, this.state);
    return (s[t] = s[e]), delete s[e], new v(s);
  }
  push(e, t) {
    const s = Object.assign({}, this.state),
      r = s[e];
    return (
      void 0 === r
        ? (s[e] = [t])
        : Array.isArray(r)
        ? (s[e] = [...r, t])
        : (s[e] = [r, t]),
      new v(s)
    );
  }
  keys() {
    return Object.keys(this.state);
  }
}
const w = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
  b = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
  ],
  x = [...[...b, ...w], "_"];
class g extends Error {
  constructor(e) {
    super(e);
  }
}
class N {
  constructor() {
    this.root = new M();
  }
  ignoreWhitespaces() {
    return this.add(" ", (e) => {});
  }
  add(e, t) {
    return "string" != typeof e
      ? ((s = e), (e = Array.isArray(s) ? s : [s]), this.addBranch(e, t))
      : this.addBranch([C(e)], t);
    var s;
  }
  addBranch(e, t) {
    return q.of(e).chainTo(this.root, t), this;
  }
  parse(e) {
    const t = [];
    for (let s = 0; s < e.length; s++) {
      const r = this.root.walk(e, s);
      if (!(r.length > 0))
        throw new g(
          N.generateParseErrorMessage(
            s,
            e,
            `did not expect character: '${e[s]}'`
          )
        );
      {
        const e = r[0],
          a = e.get();
        void 0 !== a && t.push(a), (s = e.endIndex - 1);
      }
    }
    return t;
  }
  static generateParseErrorMessage(e, t, s) {
    let r = `Parse error at index ${e} of "${t}": ${s}`;
    return (r += `\n${t}\n${" ".repeat(e)}^`), r;
  }
}
class L {
  constructor(e, t, s, r) {
    (this.text = e),
      (this.startIndex = t),
      (this.endIndex = s),
      (this.mapper = r);
  }
  get() {
    return this.mapper(this.text.substring(this.startIndex, this.endIndex));
  }
}
class F {
  static match(e) {
    return new y(e);
  }
}
class y extends F {
  constructor(e) {
    super(), (this.matcher = e);
  }
  node() {
    return new S(this.matcher);
  }
  repeats(e = 0, t = undefined) {
    return new T(this.matcher, e, t);
  }
  optional() {
    return this.repeats(0, 1);
  }
  not() {
    return new y(new O(this.matcher));
  }
}
class T extends F {
  constructor(e, t, s) {
    super(), (this.matcher = e), (this.minLength = t), (this.maxLength = s);
  }
  node() {
    return new R(this.matcher, this.minLength, this.maxLength);
  }
}
class $ extends F {
  constructor(e, t) {
    super(), (this.closeSequence = e), (this.escapeSequence = t);
  }
  node() {
    return new E(this.closeSequence, this.escapeSequence);
  }
}
class q {
  static of(e) {
    return new q(e);
  }
  constructor(e) {
    this.expressions = e;
  }
  chainTo(e, t, s = !0) {
    let r = e;
    for (let e of this.expressions)
      r = e instanceof F ? r.add(e.node()) : e.chainTo(r, t, !1);
    if (s) {
      let e = r;
      if (void 0 !== e.mapper) throw new Error("Conflicting tokens");
      e.mapper = t;
    }
    return r;
  }
}
class k {
  static of(e) {
    return new k(e);
  }
  constructor(e) {
    this.expressions = e;
  }
  chainTo(e, t, s = !0) {
    let r = e;
    r.mapper = t;
    for (let e of this.expressions)
      r = e instanceof B ? r.add(e) : e.chainTo(r, t, !1);
    if (s) {
      let e = r;
      if (void 0 !== e.mapper) throw new Error("Conflicting tokens");
      e.mapper = t;
    }
    return r;
  }
}
class B {
  constructor() {
    (this.id = B.idCounter++), (this.children = void 0);
  }
  add(e) {
    void 0 === this.children && (this.children = []);
    for (let t of this.children) if (t.equals(e)) return t;
    return this.children.push(e), e;
  }
  walkChildren(e, t, s) {
    return void 0 === this.children
      ? []
      : this.children.flatMap((r) => r.walk(e, t, s));
  }
}
B.idCounter = 1;
class M extends B {
  walk(e, t = 0, s = t) {
    return this.walkChildren(e, t, s);
  }
  equals(e) {
    return !1;
  }
}
class S extends B {
  constructor(e) {
    super(), (this.matcher = e), (this.mapper = void 0);
  }
  walk(e, t, s) {
    if (!this.matches(e, t, s)) return [];
    const r = this.walkChildren(e, t, s + 1);
    return r.length > 0
      ? r
      : void 0 !== this.mapper
      ? [new L(e, t, s + 1, this.mapper)]
      : [];
  }
  matches(e, t, s) {
    const r = e[s];
    return void 0 !== r && this.matcher.matches(r);
  }
  equals(e) {
    return e instanceof S && this.matcher.equals(e.matcher);
  }
}
class R extends B {
  constructor(e, t, s) {
    super(),
      (this.matcher = e),
      (this.minLength = t),
      (this.maxLength = s),
      (this.mapper = void 0);
  }
  walk(e, t, s) {
    const r = this.minLength,
      a = this.calculateMaxLength(e, s);
    let n = 0;
    for (
      let t = e[s];
      void 0 !== t && this.matcher.matches(t) && n < a;
      t = e[s]
    )
      s++, n++;
    if (n < r) return [];
    const i = this.walkChildren(e, t, s);
    return n > a || i.length > 0
      ? i
      : void 0 !== this.mapper
      ? [new L(e, t, s, this.mapper)]
      : [];
  }
  equals(e) {
    return (
      e instanceof R &&
      this.matcher.equals(e.matcher) &&
      this.minLength === e.minLength &&
      this.maxLength === e.maxLength
    );
  }
  calculateMaxLength(e, t) {
    const s = e.length - t;
    return void 0 !== this.maxLength ? Math.min(this.maxLength, s) : s;
  }
}
class E extends B {
  constructor(e, t) {
    super(),
      (this.closeSequence = e),
      (this.escapeSequence = t),
      (this.mapper = void 0);
  }
  walk(e, t, s) {
    for (; s < e.length; s++)
      for (
        let r = 0;
        r < this.closeSequence.length &&
        e[s + r] === this.closeSequence[r] &&
        !this.isEscaped(e, s);
        r++
      )
        if (r === this.closeSequence.length - 1) {
          const r = this.walkChildren(e, t, s);
          return r.length > 0
            ? r
            : void 0 !== this.mapper && s > t
            ? [new L(e, t, s, this.mapper)]
            : [];
        }
    return void 0 !== this.mapper && s === e.length
      ? [new L(e, t, s, this.mapper)]
      : [];
  }
  isEscaped(e, t) {
    if (void 0 === this.escapeSequence) return !1;
    for (
      let s = t - this.escapeSequence.length + 1, r = 0;
      r < this.escapeSequence.length;
      s++, r++
    ) {
      if (s < 0 && s >= t) return !1;
      if (e[s] !== this.escapeSequence[r]) return !1;
    }
    return !0;
  }
  equals(e) {
    return e instanceof E && this.closeSequence === e.closeSequence;
  }
}
class V {
  constructor(e) {
    this.character = e;
  }
  matches(e) {
    return this.character === e;
  }
  equals(e) {
    return e instanceof V && this.character === e.character;
  }
}
class A {
  constructor(e) {
    this.allowed = e;
  }
  matches(e) {
    return this.allowed.includes(e);
  }
  equals(e) {
    return (
      e instanceof A &&
      (function (e, t) {
        if (e.length !== t.length) return !1;
        for (let s = 0; s < e.length; s++) if (e[s] !== t[s]) return !1;
        return !0;
      })(this.allowed, e.allowed)
    );
  }
}
class I {
  matches(e) {
    return void 0 !== e;
  }
  equals(e) {
    return e instanceof A;
  }
}
class O {
  constructor(e) {
    this.matcher = e;
  }
  matches(e) {
    return !this.matcher.matches(e);
  }
  equals(e) {
    return e instanceof O && this.matcher.equals(e.matcher);
  }
}
function j(e) {
  return (
    Array.isArray(e) && 1 === e.length && (e = e[0]),
    F.match(Array.isArray(e) ? new A(e) : new V(e))
  );
}
function C(e) {
  return q.of(Array.from(e).map((e) => j(e)));
}
function P(...e) {
  return q.of(e.map((e) => ("string" == typeof e ? C(e) : e)));
}
function U(...e) {
  return k.of([P(...e)]);
}
function z(e, t, s = undefined) {
  return P(
    C(e),
    (function (e, t = undefined) {
      return P(new $(e, t));
    })(t, s),
    C(t)
  );
}
new (class extends F {
  constructor() {
    super(), (this.matcher = new I());
  }
  node() {
    return new S(this.matcher);
  }
  except(...e) {
    return new y(new O(new A(e)));
  }
  repeats(e = 0, t = undefined) {
    return new T(this.matcher, e, t);
  }
  optional() {
    return this.repeats(0, 1);
  }
  not() {
    return new y(new O(this.matcher));
  }
})();
const D = P(j(w).repeats(1));
P(j(x).repeats(1));
const Q = P(j([...x, ":", ".", "#", "*"]).repeats(1)),
  W = P(D),
  G = P(W, ".", D);
P(W, U(".", D));
const H = j(b);
function J(e, t) {
  switch (e) {
    case 0:
      return () => i.of(t());
    case 1:
      return (e) => {
        var s;
        return i.of(
          t(
            null !== (s = null == e ? void 0 : e.asNumber()) && void 0 !== s
              ? s
              : 0
          )
        );
      };
    case 2:
      return (e, s) => {
        var r, a;
        return i.of(
          t(
            null !== (r = null == e ? void 0 : e.asNumber()) && void 0 !== r
              ? r
              : 0,
            null !== (a = null == s ? void 0 : s.asNumber()) && void 0 !== a
              ? a
              : 0
          )
        );
      };
    case 3:
      return (e, s, r) => {
        var a, n, o;
        return i.of(
          t(
            null !== (a = null == e ? void 0 : e.asNumber()) && void 0 !== a
              ? a
              : 0,
            null !== (n = null == s ? void 0 : s.asNumber()) && void 0 !== n
              ? n
              : 0,
            null !== (o = null == r ? void 0 : r.asNumber()) && void 0 !== o
              ? o
              : 0
          )
        );
      };
    default:
      throw new Error(`Unsupported number of operands: ${e}`);
  }
}
var K;
!(function (e) {
  (e[(e.Left = 1)] = "Left"), (e[(e.Right = 2)] = "Right");
})(K || (K = {}));
class X {
  constructor(e, t, s) {
    (this.name = e), (this.operands = t), (this.fn = s);
  }
  execute(e, t, s) {
    switch (this.operands) {
      case 0:
        return this.fn();
      case 1:
        return this.fn(e);
      case 2:
        return this.fn(e, t);
      case 3:
        return this.fn(e, t, s);
      default:
        throw new Error(`Unsupported number of operands: ${this.operands}`);
    }
  }
}
class Y extends X {
  constructor(e, t, s) {
    super(e, t, s);
  }
}
class Z {
  constructor(e, t) {
    (this.name = e), (this.fn = t);
  }
  execute(e) {
    return this.fn(e);
  }
}
class _ extends X {
  constructor(e, t, s, r, a) {
    super(e, r, a),
      (this.name = e),
      (this.precedence = t),
      (this.associativity = s);
  }
}
class ee {
  constructor(e, t) {
    (this.unary = e), (this.binary = t);
  }
}
class te {
  constructor(e, t) {
    (this.key = e), (this.resolver = t);
  }
  resolve(e) {
    var t;
    return null !== (t = this.resolver(e, this.key)) && void 0 !== t
      ? t
      : i.None;
  }
  toString() {
    return this.key;
  }
}
class se {
  constructor(e, t) {
    (this.text = e), (this.decorator = t);
  }
  apply(e) {
    return this.decorator(this.text, e);
  }
}
class re {
  constructor(e, t = undefined, s = undefined) {
    (this.resolver = e), (this.prefix = t), (this.suffix = s);
  }
  resolve(e) {
    return this.prefix && this.suffix
      ? this.resolver(e).map((e) => new c(e, this.prefix, this.suffix))
      : this.resolver(e);
  }
}
class ae {
  constructor() {
    (this.bracketFn = (e) => e),
      (this.parser = new N()
        .ignoreWhitespaces()
        .add([W], (e) => parseInt(e))
        .add([G], (e) => parseFloat(e))
        .add("(", (e) => e)
        .add(")", (e) => e)
        .add(",", (e) => e)
        .add(
          z('"', '"', '\\"'),
          (e) => new re(() => i.of(e.slice(1, -1)), '"', '"')
        )
        .add(
          z("'", "'", "\\'"),
          (e) => new re(() => i.of(e.slice(1, -1)), "'", "'")
        ));
  }
  operator(e, t, s, r, a) {
    return this.parser.add(e, (n) => new _(e, t, s, r, a)), this;
  }
  biOperator(e, t, s, r, a, n, i) {
    return (
      this.parser.add(
        e,
        (o) => new ee(new _(e, t, s, 1, r), new _(e, a, n, 2, i))
      ),
      this
    );
  }
  intOperator(e, t, s, r, a) {
    return this.operator(e, t, s, r, J(r, a));
  }
  function(e, t, s) {
    return this.parser.add(e, (r) => new Y(e, t, s)), this;
  }
  varargsFunction(e, t) {
    return this.parser.add(e, (s) => new Z(e, t)), this;
  }
  intFunction(e, t, s) {
    return this.function(e, t, J(t, s));
  }
  variable(e, t, s) {
    return (
      this.parser.add(
        [C(e), H, U(Q), C(t)],
        (r) =>
          new te(r, (r, a) => s(r, a.substring(e.length, a.length - t.length)))
      ),
      this
    );
  }
  comment(e, t, s = (e, t) => t) {
    return (
      this.parser.add(
        z(e, t),
        (r) => new se(r.substring(e.length, r.length - t.length), s)
      ),
      this
    );
  }
  term(e, t) {
    return this.parser.add([C(e)], (e) => new te(e, (e) => t(e))), this;
  }
  brackets(e) {
    return (this.bracketFn = e), this;
  }
  parse(e) {
    let t = [],
      s = [],
      r = [];
    const a = this.parser.parse(e);
    for (let e = 0; e < a.length; e++) {
      let n = a[e],
        o = e > 0 ? a[e - 1] : void 0;
      if (n instanceof ee) {
        let e = n;
        (n = e.binary),
          (!o || o instanceof _ || "(" === o || "," === o) && (n = e.unary);
      }
      if (n instanceof _) {
        let e = n,
          r = s.at(-1);
        r instanceof _ &&
          (e.precedence < r.precedence ||
            (e.associativity === K.Left && e.precedence === r.precedence)) &&
          (s.pop(), t.push(r)),
          s.push(e);
      } else if (n instanceof Y) s.push(n), r.push(1);
      else if (n instanceof Z) s.push(n), r.push(1);
      else if (n instanceof te) t.push(n);
      else if (n instanceof re) t.push(n);
      else if (n instanceof se) t.push(n);
      else
        switch (n) {
          case " ":
          case "{":
          case "}":
            break;
          case ",":
            for (r[r.length - 1]++; s.length > 0; ) {
              let e = s.pop();
              if ("(" === e) {
                s.push(e);
                break;
              }
              t.push(e);
            }
            break;
          case "(":
            s.push(n);
            break;
          case ")":
            for (; s.length > 0; ) {
              let e = s.pop();
              if ("(" === e) break;
              t.push(e);
            }
            if (s.at(-1) instanceof Y) {
              const e = r.pop(),
                a = s.pop();
              if (e !== a.operands)
                throw new Error(
                  `${a.name} expected ${a.operands} parameters, but got ${e}`
                );
              t.push(a);
            } else if (s.at(-1) instanceof Z) {
              let e = r.pop();
              (e = "(" === o ? 0 : e), t.push(e), t.push(s.pop());
            }
            break;
          default:
            t.push(i.of(n));
        }
    }
    for (; s.length > 0; ) t.push(s.pop());
    return new ne(t, e);
  }
}
class ne extends u {
  static parser() {
    return new ae();
  }
  constructor(e, t) {
    super(), (this.stack = e), (this.originalFormula = t);
  }
  asFormula() {
    return this.originalFormula;
  }
  resolve(t = p.Empty) {
    let s = [],
      r = [...this.stack];
    for (; r.length > 0; ) {
      let a = r.shift();
      if (a instanceof X) {
        let t = a;
        if (0 === t.operands) s.push(t.execute());
        else if (1 === t.operands) {
          let r = s.pop();
          if (void 0 === r) throw new e(`Missing parameter #1 for "${t.name}"`);
          s.push(t.execute(r));
        } else if (2 === t.operands) {
          let r = s.pop(),
            a = s.pop();
          if (void 0 === r) throw new e(`Missing parameter #1 for "${t.name}"`);
          if (void 0 === a) throw new e(`Missing parameter #2 for "${t.name}"`);
          s.push(t.execute(a, r));
        } else {
          if (3 !== t.operands)
            throw new Error("Unsupported number of operands: " + t.operands);
          {
            let r = s.pop(),
              a = s.pop(),
              n = s.pop();
            if (void 0 === r)
              throw new e(`Missing parameter #1 for "${t.name}"`);
            if (void 0 === a)
              throw new e(`Missing parameter #2 for "${t.name}"`);
            if (void 0 === n)
              throw new e(`Missing parameter #3 for "${t.name}"`);
            s.push(t.execute(n, a, r));
          }
        }
      } else if (a instanceof Z) {
        let e = a,
          t = [],
          r = s.pop();
        for (; r-- > 0; ) t.unshift(s.pop());
        s.push(e.execute(t));
      } else if (a instanceof se) {
        const e = s.pop();
        s.push(a.apply(e));
      } else if (
        (a instanceof re && (a = a.resolve(t)),
        a instanceof te && ((a = a.resolve(t)), a instanceof ne))
      ) {
        const e = a.stack;
        for (let t = e.length - 1; t >= 0; t--) r.unshift(e[t]);
      } else {
        for (; a instanceof u; ) a = a.resolve(t);
        s.push(a);
      }
    }
    return s.pop();
  }
}
function ie(e) {
  return (...t) => i.of(e(...t.map(ue)));
}
function oe(e) {
  return (...t) => i.of(`${e}(${t.map(ue).join(",")})`);
}
function ue(e) {
  return e instanceof c ? e.asQuotedText() : e.asText();
}
class he extends i {
  asNumber() {
    throw he.UnsupportedException;
  }
  asBoolean() {
    throw he.UnsupportedException;
  }
  asList() {
    throw he.UnsupportedException;
  }
}
he.UnsupportedException = new Error("Not available for optimization");
class ce extends he {
  constructor(e) {
    super(), (this.values = []);
    let t = !1,
      s = !1;
    e.forEach((e) => {
      e instanceof ce
        ? this.values.push(...e.values)
        : e !== i.False
        ? e !== i.True
          ? this.values.push(e)
          : (t = !0)
        : (s = !0);
    }),
      t && (this.values = [i.True]),
      0 === this.values.length && (this.values = [s ? i.False : i.True]);
  }
  asText() {
    return 1 === this.values.length
      ? ue(this.values[0])
      : `any(${this.values.map(ue).join(",")})`;
  }
}
class le extends he {
  constructor(e) {
    super(), (this.values = []);
    let t = !1;
    e.forEach((e) => {
      e instanceof le
        ? this.values.push(...e.values)
        : e !== i.True && (e !== i.False ? this.values.push(e) : (t = !0));
    }),
      t && (this.values = [i.False]),
      0 === this.values.length && (this.values = [i.True]);
  }
  asText() {
    return 1 === this.values.length
      ? ue(this.values[0])
      : `all(${this.values.map(ue).join(",")})`;
  }
}
class pe extends he {
  static create(e) {
    return (t, s) => new pe(e, t, s);
  }
  constructor(e, t, s) {
    super(), (this.operator = e), (this.a = t), (this.b = s);
  }
  asText() {
    return `(${this.asTextNoBrackets()})`;
  }
  asTextNoBrackets() {
    return this.format(this.a) + this.operator + this.format(this.b);
  }
  format(e) {
    if (e instanceof pe) {
      if (
        !(
          ("+" != e.operator && "-" != e.operator) ||
          ("+" != this.operator && "-" != this.operator)
        )
      )
        return e.asTextNoBrackets();
      if (
        !(
          ("*" != e.operator && "/" != e.operator) ||
          ("*" != this.operator && "/" != this.operator)
        )
      )
        return e.asTextNoBrackets();
    }
    return ue(e);
  }
}
class fe {
  static optimize(e) {
    const t = this.Parser.parse(e).resolve();
    return t instanceof pe ? t.asTextNoBrackets() : ue(t);
  }
}
fe.Parser = ne
  .parser()
  .operator("^", 4, K.Right, 2, pe.create("^"))
  .operator("*", 3, K.Left, 2, pe.create("*"))
  .operator("/", 3, K.Left, 2, pe.create("/"))
  .operator("+", 2, K.Left, 2, pe.create("+"))
  .operator("-", 2, K.Left, 2, pe.create("-"))
  .operator(
    "!",
    2,
    K.Left,
    1,
    ie((e) => `!${e}`)
  )
  .operator(
    "<",
    3,
    K.Left,
    2,
    ie((e, t) => `${e}<${t}`)
  )
  .operator(
    "<=",
    3,
    K.Left,
    2,
    ie((e, t) => `${e}<=${t}`)
  )
  .operator(
    ">",
    3,
    K.Left,
    2,
    ie((e, t) => `${e}>${t}`)
  )
  .operator(
    ">=",
    3,
    K.Left,
    2,
    ie((e, t) => `${e}>=${t}`)
  )
  .operator(
    "==",
    3,
    K.Left,
    2,
    ie((e, t) => `${e}==${t}`)
  )
  .operator(
    "!=",
    3,
    K.Left,
    2,
    ie((e, t) => `${e}!=${t}`)
  )
  .operator("AND", 1, K.Left, 2, (e, t) => new le([e, t]))
  .operator("OR", 1, K.Left, 2, (e, t) => new ce([e, t]))
  .operator(
    "d",
    4,
    K.Left,
    2,
    ie((e, t) => `${e}d${t}`)
  )
  .term("true", () => i.of(!0))
  .term("false", () => i.of(!1))
  .term("null", () => i.of("null"))
  .function("abs", 1, oe("abs"))
  .function("min", 2, oe("min"))
  .function("max", 2, oe("max"))
  .function("floor", 1, oe("floor"))
  .function("ceil", 1, oe("ceil"))
  .function("signed", 1, oe("signed"))
  .function("if", 3, oe("if"))
  .function("concat", 2, oe("concat"))
  .function("ordinal", 1, oe("ordinal"))
  .varargsFunction("any", (e) => new ce(e))
  .varargsFunction("all", (e) => new le(e))
  .variable("@", "", (e, t) => i.of(`@${t}`))
  .variable("@{", "}", (e, t) => i.of(`@{${t}}`))
  .variable("min(@", ")", (e, t) => i.of(`min(@${t})`))
  .variable("max(@", ")", (e, t) => i.of(`max(@${t})`))
  .variable("sum(@", ")", (e, t) => i.of(`sum(@${t})`))
  .comment("[", "]", (e, t) => new c(t, "", `[${e}]`));
class de {
  constructor(e, t) {
    (this.count = e), (this.sides = t);
  }
  asText() {
    return this.count + "d" + this.sides;
  }
  asNumber() {
    return (this.count * (this.sides + 1)) / 2;
  }
  asBoolean() {
    return this.count > 0 && this.sides > 0;
  }
  asList() {
    return [this];
  }
  equals(e) {
    return e.hasValue() && this.asText() === e.asText();
  }
  toString() {
    return this.asText();
  }
  map(e) {
    return e(this);
  }
  hasValue() {
    return !0;
  }
}
class me {
  static parse(e) {
    return e instanceof u ? e : this.Parser.parse(e);
  }
  static optimize(e) {
    return fe.optimize(e);
  }
  static noneIfEmpty(e) {
    return e.length > 0 ? e : [];
  }
  static variableFn(e, t) {
    return e.get(t);
  }
  static minFn(e, t) {
    return me
      .noneIfEmpty(e.search(t))
      .flatMap((e) => e.asList())
      .reduce(me.minReduceFn, i.None);
  }
  static maxFn(e, t) {
    return me
      .noneIfEmpty(e.search(t))
      .flatMap((e) => e.asList())
      .reduce(me.maxReduceFn, i.None);
  }
  static sumFn(e, t) {
    return e
      .search(t)
      .flatMap((e) => e.asList())
      .reduce(me.addReduceFn, i.of(0));
  }
  static sumMaxFn(e, t) {
    return e
      .search(t)
      .flatMap((e) => e.asList().reduce(me.maxReduceFn))
      .reduce(me.addReduceFn, i.of(0));
  }
  static sumMinFn(e, t) {
    return e
      .search(t)
      .flatMap((e) => e.asList().reduce(me.minReduceFn))
      .reduce(me.addReduceFn, i.of(0));
  }
  static concatFn(e) {
    return i.of(e.flatMap((e) => e.asList()));
  }
  static addReduceFn(e, t) {
    return (null != e ? e : i.None).equals(i.None) &&
      (null != t ? t : i.None).equals(i.None)
      ? i.None
      : i.of(e.asNumber() + t.asNumber());
  }
  static maxReduceFn(e, t) {
    var s;
    return null !== (s = me.notNone(e, t)) && void 0 !== s
      ? s
      : e.asNumber() > t.asNumber()
      ? e
      : t;
  }
  static minReduceFn(e, t) {
    var s;
    return null !== (s = me.notNone(e, t)) && void 0 !== s
      ? s
      : e.asNumber() < t.asNumber()
      ? e
      : t;
  }
  static notNone(e, t) {
    return e.hasValue() || t.hasValue()
      ? e.hasValue()
        ? t.hasValue()
          ? null
          : e
        : t
      : i.None;
  }
}
me.Parser = ne
  .parser()
  .biOperator(
    "-",
    4,
    K.Left,
    (e) => i.of(-e.asNumber()),
    2,
    K.Left,
    (e, t) => i.of(e.asNumber() - t.asNumber())
  )
  .operator("^", 4, K.Right, 2, (e, t) =>
    i.of(Math.pow(e.asNumber(), t.asNumber()))
  )
  .operator("*", 3, K.Left, 2, (e, t) => i.of(e.asNumber() * t.asNumber()))
  .operator("/", 3, K.Left, 2, (e, t) => i.of(e.asNumber() / t.asNumber()))
  .operator("+", 2, K.Left, 2, me.addReduceFn)
  .operator("!", 2, K.Left, 1, (e) => i.of(!e.asBoolean()))
  .operator("<", 3, K.Left, 2, (e, t) => i.of(e.asNumber() < t.asNumber()))
  .operator("<=", 3, K.Left, 2, (e, t) => i.of(e.asNumber() <= t.asNumber()))
  .operator(">", 3, K.Left, 2, (e, t) => i.of(e.asNumber() > t.asNumber()))
  .operator(">=", 3, K.Left, 2, (e, t) => i.of(e.asNumber() >= t.asNumber()))
  .operator("==", 3, K.Left, 2, (e, t) => i.of(e.equals(t)))
  .operator("!=", 3, K.Left, 2, (e, t) => i.of(!e.equals(t)))
  .operator("AND", 1, K.Left, 2, (e, t) => i.of(e.asBoolean() && t.asBoolean()))
  .operator("OR", 1, K.Left, 2, (e, t) => i.of(e.asBoolean() || t.asBoolean()))
  .operator("d", 4, K.Left, 2, (e, t) => new de(e.asNumber(), t.asNumber()))
  .term("true", () => i.of(!0))
  .term("false", () => i.of(!1))
  .term("null", () => i.None)
  .function("abs", 1, (e) => i.of(Math.abs(e.asNumber())))
  .function("min", 2, (e, t) => i.of(Math.min(e.asNumber(), t.asNumber())))
  .function("max", 2, (e, t) => i.of(Math.max(e.asNumber(), t.asNumber())))
  .function("floor", 1, (e) => i.of(Math.floor(e.asNumber())))
  .function("ceil", 1, (e) => i.of(Math.ceil(e.asNumber())))
  .function("signed", 1, (e) =>
    i.of((e.asNumber() < 0 ? "" : "+") + e.asNumber())
  )
  .function("if", 3, (e, t, s) => (e.asBoolean() ? t : s))
  .varargsFunction("concat", me.concatFn)
  .function("ordinal", 1, (e) =>
    i.of(
      (function (e) {
        let t = ["th", "st", "nd", "rd"],
          s = e % 100;
        return e + (t[(s - 20) % 10] || t[s] || t[0]);
      })(e.asNumber())
    )
  )
  .varargsFunction("any", (e) => i.of(e.some((e) => e.asBoolean())))
  .varargsFunction("all", (e) => i.of(e.every((e) => e.asBoolean())))
  .variable("@", "", me.variableFn)
  .variable("@{", "}", me.variableFn)
  .variable("min(@", ")", me.minFn)
  .variable("max(@", ")", me.maxFn)
  .variable("sum(@", ")", me.sumFn)
  .variable("sum(max(@", "))", me.sumMaxFn)
  .variable("sum(min(@", "))", me.sumMinFn)
  .comment("[", "]", (e, t) => new h(t, e));
export {
  K as Associativity,
  f as BaseDataContext,
  p as DataContext,
  me as Formula,
  l as ImmutableDataContext,
  h as NamedResolvedValue,
  c as QuotedTextResolvedValue,
  u as Resolvable,
  e as ResolveError,
  i as ResolvedValue,
  o as ResolvedValueWithId,
  ne as ShuntingYard,
  ae as ShuntingYardParser,
};
//# sourceMappingURL=index.esm.js.map
